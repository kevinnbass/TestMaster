"""
Framework Adapters for Universal Test Conversion

Converts Universal Test representations to specific testing framework formats.
Directly adapted from multi-agent frameworks' tool conversion patterns.
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional
import textwrap
import json

from .universal_test import (
    UniversalTest, UniversalTestCase, UniversalTestSuite,
    TestAssertion, AssertionType, TestSetup, TestTeardown, TestFixture
)


class BaseFrameworkAdapter(ABC):
    """Base adapter for converting Universal Tests to framework-specific format."""
    
    def __init__(self, config: Dict[str, Any] = None):
        self.config = config or {}
        self.framework_name = self.__class__.__name__.replace('Adapter', '').lower()
        self.language = self.get_target_language()
    
    @abstractmethod
    def get_target_language(self) -> str:
        """Get the target programming language."""
        pass
    
    @abstractmethod
    def convert_test_suite(self, suite: UniversalTestSuite) -> str:
        """Convert Universal Test Suite to framework-specific format."""
        pass
    
    @abstractmethod
    def convert_assertion(self, assertion: TestAssertion) -> str:
        """Convert assertion to framework-specific format."""
        pass
    
    def get_file_extension(self) -> str:
        """Get appropriate file extension for test files."""
        extensions = {
            'python': '.py',
            'javascript': '.js',
            'typescript': '.ts',
            'java': '.java',
            'csharp': '.cs',
            'go': '_test.go',
            'rust': '.rs',
            'ruby': '_spec.rb'
        }
        return extensions.get(self.language, '.test')
    
    def generate_imports(self, imports: List[str]) -> str:
        """Generate import statements."""
        return '\n'.join(imports)
    
    def indent(self, code: str, level: int = 1) -> str:
        """Indent code block."""
        indent_str = '    ' * level
        return textwrap.indent(code, indent_str)


class PytestAdapter(BaseFrameworkAdapter):
    """Adapter for pytest framework - Python's most popular testing framework."""
    
    def get_target_language(self) -> str:
        return 'python'
    
    def convert_test_suite(self, suite: UniversalTestSuite) -> str:
        """Convert to pytest format."""
        lines = []
        
        # Header comment
        lines.append('"""')
        lines.append(f'Test suite: {suite.name}')
        if suite.metadata.description:
            lines.append(f'{suite.metadata.description}')
        lines.append('Generated by TestMaster Universal Test Framework')
        lines.append('"""')
        lines.append('')
        
        # Imports
        lines.append('import pytest')
        for import_stmt in suite.imports:
            lines.append(import_stmt)
        lines.append('')
        
        # Global fixtures
        for fixture in suite.global_fixtures:
            lines.append(self._convert_fixture(fixture))
            lines.append('')
        
        # Helper functions
        for helper in suite.helper_functions:
            lines.append(helper)
            lines.append('')
        
        # Test cases
        for test_case in suite.test_cases:
            lines.append(self._convert_test_case(test_case))
            lines.append('')
        
        return '\n'.join(lines)
    
    def _convert_test_case(self, test_case: UniversalTestCase) -> str:
        """Convert test case to pytest class."""
        lines = []
        
        # Skip decorator if needed
        if test_case.skip:
            reason = test_case.metadata.skip_reason or "Skipped"
            lines.append(f'@pytest.mark.skip(reason="{reason}")')
        
        # Class definition
        class_name = f"Test{test_case.name.replace(' ', '').replace('-', '_')}"
        lines.append(f'class {class_name}:')
        
        if test_case.description:
            lines.append(f'    """{test_case.description}"""')
            lines.append('')
        
        # Class-level setup/teardown
        if test_case.setup_class:
            lines.append('    @classmethod')
            lines.append('    def setup_class(cls):')
            lines.append(self.indent(test_case.setup_class.code, 2))
            lines.append('')
        
        if test_case.teardown_class:
            lines.append('    @classmethod')
            lines.append('    def teardown_class(cls):')
            lines.append(self.indent(test_case.teardown_class.code, 2))
            lines.append('')
        
        # Method-level setup/teardown
        if test_case.setup_method:
            lines.append('    def setup_method(self):')
            lines.append(self.indent(test_case.setup_method.code, 2))
            lines.append('')
        
        if test_case.teardown_method:
            lines.append('    def teardown_method(self):')
            lines.append(self.indent(test_case.teardown_method.code, 2))
            lines.append('')
        
        # Test methods
        for test in test_case.tests:
            lines.append(self._convert_test(test))
            lines.append('')
        
        # Nested suites as inner classes
        for nested_suite in test_case.nested_suites:
            nested_code = self._convert_test_case(nested_suite)
            lines.append(self.indent(nested_code, 1))
            lines.append('')
        
        return '\n'.join(lines).rstrip()
    
    def _convert_test(self, test: UniversalTest) -> str:
        """Convert individual test to pytest method."""
        lines = []
        
        # Decorators
        decorators = []
        
        if test.skip:
            reason = test.metadata.skip_reason or "Skipped"
            decorators.append(f'@pytest.mark.skip(reason="{reason}")')
        
        if test.skip_condition:
            decorators.append(f'@pytest.mark.skipif({test.skip_condition}, reason="Conditional skip")')
        
        if test.metadata.tags:
            for tag in test.metadata.tags:
                decorators.append(f'@pytest.mark.{tag}')
        
        if test.timeout:
            decorators.append(f'@pytest.mark.timeout({test.timeout / 1000})')
        
        if test.parameters:
            # Parameterized test
            param_values = [(p.value,) for p in test.parameters]
            decorators.append(f'@pytest.mark.parametrize("input_value", {param_values})')
        
        if test.is_async:
            decorators.append('@pytest.mark.asyncio')
        
        for decorator in decorators:
            lines.append(f'    {decorator}')
        
        # Method definition
        method_name = f"test_{test.name.lower().replace(' ', '_').replace('-', '_')}"
        if test.is_async:
            if test.fixtures:
                lines.append(f'    async def {method_name}(self, {", ".join(test.fixtures)}):')
            else:
                lines.append(f'    async def {method_name}(self):')
        else:
            if test.fixtures:
                lines.append(f'    def {method_name}(self, {", ".join(test.fixtures)}):')
            else:
                lines.append(f'    def {method_name}(self):')
        
        # Docstring
        if test.description:
            lines.append(f'        """{test.description}"""')
        
        # Setup
        if test.setup:
            lines.append(self.indent(test.setup.code, 2))
        
        # Test body
        lines.append(self.indent(test.test_function, 2))
        
        # Assertions
        for assertion in test.assertions:
            assertion_code = self.convert_assertion(assertion)
            lines.append(self.indent(assertion_code, 2))
        
        # Teardown
        if test.teardown:
            lines.append(self.indent(test.teardown.code, 2))
        
        return '\n'.join(lines)
    
    def _convert_fixture(self, fixture: TestFixture) -> str:
        """Convert fixture to pytest fixture."""
        lines = []
        
        # Fixture decorator
        decorator_args = []
        if fixture.scope != "function":
            decorator_args.append(f'scope="{fixture.scope}"')
        if fixture.autouse:
            decorator_args.append('autouse=True')
        if fixture.params:
            param_values = [p.value for p in fixture.params]
            decorator_args.append(f'params={param_values}')
        
        if decorator_args:
            lines.append(f'@pytest.fixture({", ".join(decorator_args)})')
        else:
            lines.append('@pytest.fixture')
        
        # Fixture function
        if fixture.is_async:
            lines.append(f'async def {fixture.name}():')
        else:
            lines.append(f'def {fixture.name}():')
        
        if fixture.description:
            lines.append(f'    """{fixture.description}"""')
        
        # Setup code
        lines.append(self.indent(fixture.setup_code, 1))
        
        # Teardown code (using yield)
        if fixture.teardown_code:
            lines.append('    yield')
            lines.append(self.indent(fixture.teardown_code, 1))
        
        return '\n'.join(lines)
    
    def convert_assertion(self, assertion: TestAssertion) -> str:
        """Convert assertion to pytest format."""
        actual = assertion.actual
        expected = assertion.expected
        message = f', "{assertion.message}"' if assertion.message else ''
        
        assertion_map = {
            AssertionType.EQUAL: f'assert {actual} == {repr(expected)}{message}',
            AssertionType.NOT_EQUAL: f'assert {actual} != {repr(expected)}{message}',
            AssertionType.TRUE: f'assert {actual}{message}',
            AssertionType.FALSE: f'assert not {actual}{message}',
            AssertionType.NULL: f'assert {actual} is None{message}',
            AssertionType.NOT_NULL: f'assert {actual} is not None{message}',
            AssertionType.CONTAINS: f'assert {repr(expected)} in {actual}{message}',
            AssertionType.NOT_CONTAINS: f'assert {repr(expected)} not in {actual}{message}',
            AssertionType.GREATER_THAN: f'assert {actual} > {repr(expected)}{message}',
            AssertionType.LESS_THAN: f'assert {actual} < {repr(expected)}{message}',
            AssertionType.GREATER_EQUAL: f'assert {actual} >= {repr(expected)}{message}',
            AssertionType.LESS_EQUAL: f'assert {actual} <= {repr(expected)}{message}',
            AssertionType.INSTANCE_OF: f'assert isinstance({actual}, {expected}){message}',
            AssertionType.LENGTH: f'assert len({actual}) == {repr(expected)}{message}',
            AssertionType.MATCHES: f'assert re.match({repr(expected)}, {actual}){message}',
            AssertionType.DEEP_EQUAL: f'assert {actual} == {repr(expected)}{message}',
            AssertionType.CLOSE_TO: f'assert pytest.approx({actual}, {assertion.tolerance}) == {repr(expected)}{message}',
        }
        
        if assertion.assertion_type == AssertionType.THROWS:
            exception_type = assertion.exception_type or 'Exception'
            return f'with pytest.raises({exception_type}){message}:\n    {actual}'
        
        return assertion_map.get(assertion.assertion_type, f'assert {actual}  # Unknown assertion type')


class JestAdapter(BaseFrameworkAdapter):
    """Adapter for Jest framework - JavaScript's popular testing framework."""
    
    def get_target_language(self) -> str:
        return 'javascript'
    
    def convert_test_suite(self, suite: UniversalTestSuite) -> str:
        """Convert to Jest format."""
        lines = []
        
        # Header comment
        lines.append('/**')
        lines.append(f' * Test suite: {suite.name}')
        if suite.metadata.description:
            lines.append(f' * {suite.metadata.description}')
        lines.append(' * Generated by TestMaster Universal Test Framework')
        lines.append(' */')
        lines.append('')
        
        # Imports
        for import_stmt in suite.imports:
            lines.append(import_stmt)
        lines.append('')
        
        # Helper functions
        for helper in suite.helper_functions:
            lines.append(helper)
            lines.append('')
        
        # Global setup/teardown
        if suite.global_setup:
            lines.append('beforeAll(() => {')
            lines.append(self.indent(suite.global_setup.code))
            lines.append('});')
            lines.append('')
        
        if suite.global_teardown:
            lines.append('afterAll(() => {')
            lines.append(self.indent(suite.global_teardown.code))
            lines.append('});')
            lines.append('')
        
        # Test cases
        for test_case in suite.test_cases:
            lines.append(self._convert_test_case(test_case))
            lines.append('')
        
        return '\n'.join(lines)
    
    def _convert_test_case(self, test_case: UniversalTestCase) -> str:
        """Convert test case to Jest describe block."""
        lines = []
        
        # Skip modifier if needed
        modifier = ''
        if test_case.skip:
            modifier = '.skip'
        elif test_case.only:
            modifier = '.only'
        
        # Describe block
        lines.append(f'describe{modifier}("{test_case.name}", () => {{')
        
        # Setup/teardown
        if test_case.setup_method:
            if test_case.setup_method.is_async:
                lines.append('    beforeEach(async () => {')
            else:
                lines.append('    beforeEach(() => {')
            lines.append(self.indent(test_case.setup_method.code, 2))
            lines.append('    });')
            lines.append('')
        
        if test_case.teardown_method:
            if test_case.teardown_method.is_async:
                lines.append('    afterEach(async () => {')
            else:
                lines.append('    afterEach(() => {')
            lines.append(self.indent(test_case.teardown_method.code, 2))
            lines.append('    });')
            lines.append('')
        
        # Tests
        for test in test_case.tests:
            test_code = self._convert_test(test)
            lines.append(self.indent(test_code))
            lines.append('')
        
        # Nested describes
        for nested_suite in test_case.nested_suites:
            nested_code = self._convert_test_case(nested_suite)
            lines.append(self.indent(nested_code))
            lines.append('')
        
        lines.append('});')
        
        return '\n'.join(lines).rstrip()
    
    def _convert_test(self, test: UniversalTest) -> str:
        """Convert individual test to Jest it block."""
        lines = []
        
        # Skip/only modifier
        modifier = ''
        if test.skip:
            modifier = '.skip'
        elif test.only:
            modifier = '.only'
        
        # Test block
        if test.is_async:
            lines.append(f'it{modifier}("{test.name}", async () => {{')
        else:
            lines.append(f'it{modifier}("{test.name}", () => {{')
        
        # Setup
        if test.setup:
            lines.append(self.indent(test.setup.code))
        
        # Test body
        lines.append(self.indent(test.test_function))
        
        # Assertions
        for assertion in test.assertions:
            assertion_code = self.convert_assertion(assertion)
            lines.append(self.indent(assertion_code))
        
        # Teardown
        if test.teardown:
            lines.append(self.indent(test.teardown.code))
        
        # Timeout
        if test.timeout:
            lines.append(f'}}, {test.timeout});')
        else:
            lines.append('});')
        
        return '\n'.join(lines)
    
    def convert_assertion(self, assertion: TestAssertion) -> str:
        """Convert assertion to Jest format."""
        actual = assertion.actual
        expected = assertion.expected
        
        assertion_map = {
            AssertionType.EQUAL: f'expect({actual}).toBe({json.dumps(expected)});',
            AssertionType.NOT_EQUAL: f'expect({actual}).not.toBe({json.dumps(expected)});',
            AssertionType.TRUE: f'expect({actual}).toBeTruthy();',
            AssertionType.FALSE: f'expect({actual}).toBeFalsy();',
            AssertionType.NULL: f'expect({actual}).toBeNull();',
            AssertionType.NOT_NULL: f'expect({actual}).not.toBeNull();',
            AssertionType.CONTAINS: f'expect({actual}).toContain({json.dumps(expected)});',
            AssertionType.NOT_CONTAINS: f'expect({actual}).not.toContain({json.dumps(expected)});',
            AssertionType.GREATER_THAN: f'expect({actual}).toBeGreaterThan({json.dumps(expected)});',
            AssertionType.LESS_THAN: f'expect({actual}).toBeLessThan({json.dumps(expected)});',
            AssertionType.GREATER_EQUAL: f'expect({actual}).toBeGreaterThanOrEqual({json.dumps(expected)});',
            AssertionType.LESS_EQUAL: f'expect({actual}).toBeLessThanOrEqual({json.dumps(expected)});',
            AssertionType.INSTANCE_OF: f'expect({actual}).toBeInstanceOf({expected});',
            AssertionType.LENGTH: f'expect({actual}).toHaveLength({json.dumps(expected)});',
            AssertionType.MATCHES: f'expect({actual}).toMatch({expected});',
            AssertionType.DEEP_EQUAL: f'expect({actual}).toEqual({json.dumps(expected)});',
            AssertionType.CLOSE_TO: f'expect({actual}).toBeCloseTo({json.dumps(expected)}, {assertion.tolerance or 2});',
            AssertionType.RESOLVED: f'await expect({actual}).resolves.toBe({json.dumps(expected)});',
            AssertionType.REJECTED: f'await expect({actual}).rejects.toThrow();',
        }
        
        if assertion.assertion_type == AssertionType.THROWS:
            if assertion.exception_type:
                return f'expect(() => {actual}).toThrow({assertion.exception_type});'
            return f'expect(() => {actual}).toThrow();'
        
        return assertion_map.get(assertion.assertion_type, f'expect({actual}).toBe(true); // Unknown assertion')


class UnittestAdapter(BaseFrameworkAdapter):
    """Adapter for Python's built-in unittest framework."""
    
    def get_target_language(self) -> str:
        return 'python'
    
    def convert_test_suite(self, suite: UniversalTestSuite) -> str:
        """Convert to unittest format."""
        lines = []
        
        # Header
        lines.append('"""')
        lines.append(f'Test suite: {suite.name}')
        lines.append('Generated by TestMaster Universal Test Framework')
        lines.append('"""')
        lines.append('')
        lines.append('import unittest')
        
        # Additional imports
        for import_stmt in suite.imports:
            lines.append(import_stmt)
        lines.append('')
        
        # Helper functions
        for helper in suite.helper_functions:
            lines.append(helper)
            lines.append('')
        
        # Test cases
        for test_case in suite.test_cases:
            lines.append(self._convert_test_case(test_case))
            lines.append('')
        
        # Main execution
        lines.append('if __name__ == "__main__":')
        lines.append('    unittest.main()')
        
        return '\n'.join(lines)
    
    def _convert_test_case(self, test_case: UniversalTestCase) -> str:
        """Convert test case to unittest TestCase class."""
        lines = []
        
        # Skip decorator if needed
        if test_case.skip:
            reason = test_case.metadata.skip_reason or "Skipped"
            lines.append(f'@unittest.skip("{reason}")')
        
        # Class definition
        class_name = f"Test{test_case.name.replace(' ', '').replace('-', '_')}"
        lines.append(f'class {class_name}(unittest.TestCase):')
        
        if test_case.description:
            lines.append(f'    """{test_case.description}"""')
            lines.append('')
        
        # Class-level setup/teardown
        if test_case.setup_class:
            lines.append('    @classmethod')
            lines.append('    def setUpClass(cls):')
            lines.append(self.indent(test_case.setup_class.code, 2))
            lines.append('')
        
        if test_case.teardown_class:
            lines.append('    @classmethod')
            lines.append('    def tearDownClass(cls):')
            lines.append(self.indent(test_case.teardown_class.code, 2))
            lines.append('')
        
        # Method-level setup/teardown
        if test_case.setup_method:
            lines.append('    def setUp(self):')
            lines.append(self.indent(test_case.setup_method.code, 2))
            lines.append('')
        
        if test_case.teardown_method:
            lines.append('    def tearDown(self):')
            lines.append(self.indent(test_case.teardown_method.code, 2))
            lines.append('')
        
        # Test methods
        for test in test_case.tests:
            lines.append(self._convert_test(test))
            lines.append('')
        
        return '\n'.join(lines).rstrip()
    
    def _convert_test(self, test: UniversalTest) -> str:
        """Convert individual test to unittest method."""
        lines = []
        
        # Skip decorator
        if test.skip:
            reason = test.metadata.skip_reason or "Skipped"
            lines.append(f'    @unittest.skip("{reason}")')
        
        if test.skip_condition:
            lines.append(f'    @unittest.skipIf({test.skip_condition}, "Conditional skip")')
        
        # Method definition
        method_name = f"test_{test.name.lower().replace(' ', '_').replace('-', '_')}"
        lines.append(f'    def {method_name}(self):')
        
        # Docstring
        if test.description:
            lines.append(f'        """{test.description}"""')
        
        # Test body
        lines.append(self.indent(test.test_function, 2))
        
        # Assertions
        for assertion in test.assertions:
            assertion_code = self.convert_assertion(assertion)
            lines.append(self.indent(assertion_code, 2))
        
        return '\n'.join(lines)
    
    def convert_assertion(self, assertion: TestAssertion) -> str:
        """Convert assertion to unittest format."""
        actual = assertion.actual
        expected = assertion.expected
        message = f', "{assertion.message}"' if assertion.message else ''
        
        assertion_map = {
            AssertionType.EQUAL: f'self.assertEqual({actual}, {repr(expected)}{message})',
            AssertionType.NOT_EQUAL: f'self.assertNotEqual({actual}, {repr(expected)}{message})',
            AssertionType.TRUE: f'self.assertTrue({actual}{message})',
            AssertionType.FALSE: f'self.assertFalse({actual}{message})',
            AssertionType.NULL: f'self.assertIsNone({actual}{message})',
            AssertionType.NOT_NULL: f'self.assertIsNotNone({actual}{message})',
            AssertionType.CONTAINS: f'self.assertIn({repr(expected)}, {actual}{message})',
            AssertionType.NOT_CONTAINS: f'self.assertNotIn({repr(expected)}, {actual}{message})',
            AssertionType.GREATER_THAN: f'self.assertGreater({actual}, {repr(expected)}{message})',
            AssertionType.LESS_THAN: f'self.assertLess({actual}, {repr(expected)}{message})',
            AssertionType.GREATER_EQUAL: f'self.assertGreaterEqual({actual}, {repr(expected)}{message})',
            AssertionType.LESS_EQUAL: f'self.assertLessEqual({actual}, {repr(expected)}{message})',
            AssertionType.INSTANCE_OF: f'self.assertIsInstance({actual}, {expected}{message})',
            AssertionType.LENGTH: f'self.assertEqual(len({actual}), {repr(expected)}{message})',
            AssertionType.MATCHES: f'self.assertRegex({actual}, {repr(expected)}{message})',
            AssertionType.DEEP_EQUAL: f'self.assertEqual({actual}, {repr(expected)}{message})',
            AssertionType.CLOSE_TO: f'self.assertAlmostEqual({actual}, {repr(expected)}, delta={assertion.tolerance}{message})',
        }
        
        if assertion.assertion_type == AssertionType.THROWS:
            exception_type = assertion.exception_type or 'Exception'
            return f'with self.assertRaises({exception_type}{message}):\n    {actual}'
        
        return assertion_map.get(assertion.assertion_type, f'self.assertTrue({actual})  # Unknown assertion')


class MochaAdapter(JestAdapter):
    """Adapter for Mocha framework - Another popular JavaScript testing framework."""
    
    def convert_test_suite(self, suite: UniversalTestSuite) -> str:
        """Convert to Mocha format (similar to Jest but with different syntax)."""
        lines = []
        
        # Header
        lines.append('/**')
        lines.append(f' * Test suite: {suite.name}')
        lines.append(' * Generated by TestMaster for Mocha')
        lines.append(' */')
        lines.append('')
        
        # Imports (usually chai for assertions)
        lines.append("const { expect } = require('chai');")
        for import_stmt in suite.imports:
            lines.append(import_stmt)
        lines.append('')
        
        # Test cases
        for test_case in suite.test_cases:
            lines.append(self._convert_test_case_mocha(test_case))
            lines.append('')
        
        return '\n'.join(lines)
    
    def _convert_test_case_mocha(self, test_case: UniversalTestCase) -> str:
        """Convert test case to Mocha describe block."""
        lines = []
        
        # Describe block
        lines.append(f'describe("{test_case.name}", function() {{')
        
        # Setup/teardown using before/after
        if test_case.setup_method:
            lines.append('    beforeEach(function() {')
            lines.append(self.indent(test_case.setup_method.code, 2))
            lines.append('    });')
        
        if test_case.teardown_method:
            lines.append('    afterEach(function() {')
            lines.append(self.indent(test_case.teardown_method.code, 2))
            lines.append('    });')
        
        # Tests
        for test in test_case.tests:
            test_code = self._convert_test_mocha(test)
            lines.append(self.indent(test_code))
        
        lines.append('});')
        
        return '\n'.join(lines)
    
    def _convert_test_mocha(self, test: UniversalTest) -> str:
        """Convert test to Mocha it block."""
        lines = []
        
        if test.is_async:
            lines.append(f'it("{test.name}", async function() {{')
        else:
            lines.append(f'it("{test.name}", function() {{')
        
        lines.append(self.indent(test.test_function))
        
        # Convert assertions to chai format
        for assertion in test.assertions:
            assertion_code = self._convert_chai_assertion(assertion)
            lines.append(self.indent(assertion_code))
        
        lines.append('});')
        
        return '\n'.join(lines)
    
    def _convert_chai_assertion(self, assertion: TestAssertion) -> str:
        """Convert assertion to Chai format."""
        actual = assertion.actual
        expected = assertion.expected
        
        assertion_map = {
            AssertionType.EQUAL: f'expect({actual}).to.equal({json.dumps(expected)});',
            AssertionType.NOT_EQUAL: f'expect({actual}).to.not.equal({json.dumps(expected)});',
            AssertionType.TRUE: f'expect({actual}).to.be.true;',
            AssertionType.FALSE: f'expect({actual}).to.be.false;',
            AssertionType.NULL: f'expect({actual}).to.be.null;',
            AssertionType.NOT_NULL: f'expect({actual}).to.not.be.null;',
            AssertionType.CONTAINS: f'expect({actual}).to.include({json.dumps(expected)});',
            AssertionType.GREATER_THAN: f'expect({actual}).to.be.above({json.dumps(expected)});',
            AssertionType.LESS_THAN: f'expect({actual}).to.be.below({json.dumps(expected)});',
        }
        
        return assertion_map.get(assertion.assertion_type, f'expect({actual}).to.be.ok;')


# Additional framework adapters (stubs for now)
class JUnitAdapter(BaseFrameworkAdapter):
    """Adapter for JUnit framework - Java."""
    def get_target_language(self) -> str:
        return 'java'
    
    def convert_test_suite(self, suite: UniversalTestSuite) -> str:
        # Implementation would convert to JUnit format
        return f"// JUnit test suite for {suite.name}"
    
    def convert_assertion(self, assertion: TestAssertion) -> str:
        return f"assertEquals(expected, actual);"


class NUnitAdapter(BaseFrameworkAdapter):
    """Adapter for NUnit framework - C#."""
    def get_target_language(self) -> str:
        return 'csharp'
    
    def convert_test_suite(self, suite: UniversalTestSuite) -> str:
        return f"// NUnit test suite for {suite.name}"
    
    def convert_assertion(self, assertion: TestAssertion) -> str:
        return f"Assert.AreEqual(expected, actual);"


class XUnitAdapter(BaseFrameworkAdapter):
    """Adapter for xUnit framework - C#."""
    def get_target_language(self) -> str:
        return 'csharp'
    
    def convert_test_suite(self, suite: UniversalTestSuite) -> str:
        return f"// xUnit test suite for {suite.name}"
    
    def convert_assertion(self, assertion: TestAssertion) -> str:
        return f"Assert.Equal(expected, actual);"


class GoTestAdapter(BaseFrameworkAdapter):
    """Adapter for Go testing framework."""
    def get_target_language(self) -> str:
        return 'go'
    
    def convert_test_suite(self, suite: UniversalTestSuite) -> str:
        return f"// Go test suite for {suite.name}"
    
    def convert_assertion(self, assertion: TestAssertion) -> str:
        return f"assert.Equal(t, expected, actual)"


class RustTestAdapter(BaseFrameworkAdapter):
    """Adapter for Rust testing framework."""
    def get_target_language(self) -> str:
        return 'rust'
    
    def convert_test_suite(self, suite: UniversalTestSuite) -> str:
        return f"// Rust test suite for {suite.name}"
    
    def convert_assertion(self, assertion: TestAssertion) -> str:
        return f"assert_eq!(actual, expected);"


class RSpecAdapter(BaseFrameworkAdapter):
    """Adapter for RSpec framework - Ruby."""
    def get_target_language(self) -> str:
        return 'ruby'
    
    def convert_test_suite(self, suite: UniversalTestSuite) -> str:
        return f"# RSpec test suite for {suite.name}"
    
    def convert_assertion(self, assertion: TestAssertion) -> str:
        return f"expect(actual).to eq(expected)"


class MinitestAdapter(BaseFrameworkAdapter):
    """Adapter for Minitest framework - Ruby."""
    def get_target_language(self) -> str:
        return 'ruby'
    
    def convert_test_suite(self, suite: UniversalTestSuite) -> str:
        return f"# Minitest suite for {suite.name}"
    
    def convert_assertion(self, assertion: TestAssertion) -> str:
        return f"assert_equal expected, actual"


class FrameworkAdapterRegistry:
    """Registry for framework adapters - Adapted from Agency Swarm's tool registry."""
    
    _adapters: Dict[str, BaseFrameworkAdapter] = {}
    
    @classmethod
    def register_adapter(cls, framework: str, adapter: BaseFrameworkAdapter):
        """Register a framework adapter."""
        cls._adapters[framework.lower()] = adapter
    
    @classmethod
    def get_adapter(cls, framework: str) -> Optional[BaseFrameworkAdapter]:
        """Get adapter for framework."""
        if not cls._adapters:
            cls._initialize_default_adapters()
        return cls._adapters.get(framework.lower())
    
    @classmethod
    def get_all_adapters(cls) -> Dict[str, BaseFrameworkAdapter]:
        """Get all registered adapters."""
        if not cls._adapters:
            cls._initialize_default_adapters()
        return cls._adapters.copy()
    
    @classmethod
    def supports_framework(cls, framework: str) -> bool:
        """Check if framework is supported."""
        if not cls._adapters:
            cls._initialize_default_adapters()
        return framework.lower() in cls._adapters
    
    @classmethod
    def list_supported_frameworks(cls) -> List[str]:
        """List all supported frameworks."""
        if not cls._adapters:
            cls._initialize_default_adapters()
        return list(cls._adapters.keys())
    
    @classmethod
    def _initialize_default_adapters(cls):
        """Initialize default framework adapters."""
        adapters = [
            ('pytest', PytestAdapter()),
            ('unittest', UnittestAdapter()),
            ('jest', JestAdapter()),
            ('mocha', MochaAdapter()),
            ('junit', JUnitAdapter()),
            ('nunit', NUnitAdapter()),
            ('xunit', XUnitAdapter()),
            ('go', GoTestAdapter()),
            ('rust', RustTestAdapter()),
            ('rspec', RSpecAdapter()),
            ('minitest', MinitestAdapter()),
        ]
        
        for framework, adapter in adapters:
            cls.register_adapter(framework, adapter)


# Initialize default adapters
FrameworkAdapterRegistry._initialize_default_adapters()