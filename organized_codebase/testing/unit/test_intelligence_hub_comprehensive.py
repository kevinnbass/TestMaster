#!/usr/bin/env python3
"""
Comprehensive test suite for Intelligence Hub
Generated by Agent D Test Blueprint Implementation
Coverage: Core intelligence functionality, security, and integration
"""

import pytest
import asyncio
import sys
import os
from unittest.mock import Mock, patch, MagicMock, AsyncMock
from typing import Dict, Any, List
import json
import time

# Add TestMaster to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

try:
    from TestMaster.core.intelligence import IntelligenceHub
    from TestMaster.core.intelligence.analytics.analytics_hub import ConsolidatedAnalyticsHub
    from TestMaster.core.intelligence.testing.components.coverage_analyzer import CoverageAnalyzer
    from TestMaster.core.intelligence.integration.components.cross_system_analyzer import CrossSystemAnalyzer
except ImportError as e:
    # Mock imports if modules don't exist yet
    print(f"Import warning: {e}")
    IntelligenceHub = Mock
    ConsolidatedAnalyticsHub = Mock
    CoverageAnalyzer = Mock
    CrossSystemAnalyzer = Mock


class TestIntelligenceHubInitialization:
    """Test Intelligence Hub initialization and basic functionality"""
    
    def test_intelligence_hub_initialization_success(self):
        """Test successful IntelligenceHub initialization"""
        # Arrange
        with patch('TestMaster.core.intelligence.ConsolidatedAnalyticsHub'), \
             patch('TestMaster.core.intelligence.ConsolidatedTestingHub'), \
             patch('TestMaster.core.intelligence.ConsolidatedIntegrationHub'):
            
            # Act
            hub = IntelligenceHub()
            
            # Assert
            assert hub is not None
            assert hasattr(hub, 'analytics_hub')
            assert hasattr(hub, 'testing_hub')
            assert hasattr(hub, 'integration_hub')
    
    def test_intelligence_hub_initialization_with_config(self):
        """Test IntelligenceHub initialization with custom configuration"""
        # Arrange
        config = {
            'analytics_enabled': True,
            'testing_enabled': True,
            'integration_enabled': True,
            'debug_mode': False
        }
        
        with patch('TestMaster.core.intelligence.ConsolidatedAnalyticsHub'), \
             patch('TestMaster.core.intelligence.ConsolidatedTestingHub'), \
             patch('TestMaster.core.intelligence.ConsolidatedIntegrationHub'):
            
            # Act
            hub = IntelligenceHub(config=config)
            
            # Assert
            assert hub is not None
            # Verify configuration was applied
    
    def test_intelligence_hub_initialization_failure_handling(self):
        """Test IntelligenceHub handles initialization failures gracefully"""
        # Arrange
        with patch('TestMaster.core.intelligence.ConsolidatedAnalyticsHub', side_effect=Exception("Analytics init failed")):
            
            # Act & Assert
            with pytest.raises(Exception):
                IntelligenceHub()
    
    def test_intelligence_hub_component_availability(self):
        """Test that all required components are available after initialization"""
        # Arrange & Act
        with patch('TestMaster.core.intelligence.ConsolidatedAnalyticsHub'), \
             patch('TestMaster.core.intelligence.ConsolidatedTestingHub'), \
             patch('TestMaster.core.intelligence.ConsolidatedIntegrationHub'):
            
            hub = IntelligenceHub()
            
            # Assert
            assert hub.analytics_hub is not None
            assert hub.testing_hub is not None
            assert hub.integration_hub is not None


class TestIntelligenceHubAnalysis:
    """Test Intelligence Hub analysis capabilities"""
    
    @pytest.fixture
    def mock_hub(self):
        """Create a mocked Intelligence Hub for testing"""
        with patch('TestMaster.core.intelligence.ConsolidatedAnalyticsHub') as mock_analytics, \
             patch('TestMaster.core.intelligence.ConsolidatedTestingHub') as mock_testing, \
             patch('TestMaster.core.intelligence.ConsolidatedIntegrationHub') as mock_integration:
            
            hub = IntelligenceHub()
            hub.analytics_hub = mock_analytics
            hub.testing_hub = mock_testing
            hub.integration_hub = mock_integration
            return hub
    
    @pytest.mark.asyncio
    async def test_comprehensive_analysis_success(self, mock_hub):
        """Test successful comprehensive analysis"""
        # Arrange
        test_data = {
            'project_path': '/test/project',
            'analysis_type': 'comprehensive',
            'include_security': True
        }
        
        expected_result = {
            'analytics': {'status': 'success', 'metrics': {}},
            'testing': {'status': 'success', 'coverage': 85.5},
            'integration': {'status': 'success', 'systems': 5}
        }
        
        mock_hub.analytics_hub.analyze_comprehensive.return_value = expected_result['analytics']
        mock_hub.testing_hub.analyze_coverage.return_value = expected_result['testing']
        mock_hub.integration_hub.analyze_systems.return_value = expected_result['integration']
        
        # Act
        result = await mock_hub.analyze_comprehensive(test_data)
        
        # Assert
        assert 'analytics' in result
        assert 'testing' in result
        assert 'integration' in result
        assert result['analytics']['status'] == 'success'
        assert result['testing']['coverage'] == 85.5
    
    def test_analysis_with_invalid_input(self, mock_hub):
        """Test analysis with invalid input data"""
        # Arrange
        invalid_data = None
        
        # Act & Assert
        with pytest.raises(ValueError):
            mock_hub.analyze_comprehensive(invalid_data)
    
    def test_analysis_partial_failure_handling(self, mock_hub):
        """Test analysis continues when one component fails"""
        # Arrange
        test_data = {'project_path': '/test/project'}
        
        mock_hub.analytics_hub.analyze_comprehensive.side_effect = Exception("Analytics failed")
        mock_hub.testing_hub.analyze_coverage.return_value = {'status': 'success', 'coverage': 75.0}
        mock_hub.integration_hub.analyze_systems.return_value = {'status': 'success', 'systems': 3}
        
        # Act
        result = mock_hub.analyze_comprehensive(test_data)
        
        # Assert
        assert 'analytics' in result
        assert result['analytics']['status'] == 'error'
        assert result['testing']['status'] == 'success'
        assert result['integration']['status'] == 'success'
    
    @pytest.mark.parametrize("analysis_type,expected_components", [
        ('analytics_only', ['analytics']),
        ('testing_only', ['testing']),
        ('integration_only', ['integration']),
        ('analytics_testing', ['analytics', 'testing']),
        ('comprehensive', ['analytics', 'testing', 'integration'])
    ])
    def test_selective_analysis(self, mock_hub, analysis_type, expected_components):
        """Test selective analysis based on analysis type"""
        # Arrange
        test_data = {
            'project_path': '/test/project',
            'analysis_type': analysis_type
        }
        
        # Act
        result = mock_hub.analyze_selective(test_data)
        
        # Assert
        for component in expected_components:
            assert component in result
        
        # Ensure only expected components are present
        assert len(result) == len(expected_components)


class TestIntelligenceHubSecurity:
    """Test Intelligence Hub security features"""
    
    def test_input_validation_security(self):
        """Test input validation prevents injection attacks"""
        # Arrange
        malicious_inputs = [
            "'; DROP TABLE analysis; --",
            "__import__('os').system('rm -rf /')",
            "eval('malicious_code')",
            "<script>alert('XSS')</script>",
            "../../etc/passwd"
        ]
        
        with patch('TestMaster.core.intelligence.ConsolidatedAnalyticsHub'), \
             patch('TestMaster.core.intelligence.ConsolidatedTestingHub'), \
             patch('TestMaster.core.intelligence.ConsolidatedIntegrationHub'):
            
            hub = IntelligenceHub()
            
            # Act & Assert
            for malicious_input in malicious_inputs:
                test_data = {'project_path': malicious_input}
                
                # Should either sanitize input or raise appropriate exception
                try:
                    result = hub.analyze_comprehensive(test_data)
                    # If it doesn't raise an exception, ensure input was sanitized
                    assert malicious_input not in str(result)
                except (ValueError, SecurityError, Exception):
                    # Expected for malicious input
                    pass
    
    def test_authentication_required_for_sensitive_operations(self):
        """Test that sensitive operations require authentication"""
        # Arrange
        with patch('TestMaster.core.intelligence.ConsolidatedAnalyticsHub'), \
             patch('TestMaster.core.intelligence.ConsolidatedTestingHub'), \
             patch('TestMaster.core.intelligence.ConsolidatedIntegrationHub'):
            
            hub = IntelligenceHub()
            
            # Act & Assert
            sensitive_operations = [
                'delete_analysis_data',
                'modify_system_config',
                'export_sensitive_data'
            ]
            
            for operation in sensitive_operations:
                if hasattr(hub, operation):
                    with pytest.raises((PermissionError, AuthenticationError, Exception)):
                        getattr(hub, operation)()
    
    def test_rate_limiting_protection(self):
        """Test that rate limiting protects against DoS attacks"""
        # Arrange
        with patch('TestMaster.core.intelligence.ConsolidatedAnalyticsHub'), \
             patch('TestMaster.core.intelligence.ConsolidatedTestingHub'), \
             patch('TestMaster.core.intelligence.ConsolidatedIntegrationHub'):
            
            hub = IntelligenceHub()
            test_data = {'project_path': '/test/project'}
            
            # Act - Make many rapid requests
            requests_made = 0
            rate_limited = False
            
            for i in range(100):  # Attempt 100 rapid requests
                try:
                    result = hub.analyze_comprehensive(test_data)
                    requests_made += 1
                except (RateLimitError, Exception) as e:
                    if "rate limit" in str(e).lower():
                        rate_limited = True
                        break
            
            # Assert
            # Either requests were rate limited, or all succeeded within reasonable limits
            assert rate_limited or requests_made <= 50  # Allow some requests but not unlimited


class TestIntelligenceHubPerformance:
    """Test Intelligence Hub performance characteristics"""
    
    @pytest.mark.performance
    def test_analysis_response_time(self):
        """Test that analysis completes within acceptable time limits"""
        # Arrange
        with patch('TestMaster.core.intelligence.ConsolidatedAnalyticsHub'), \
             patch('TestMaster.core.intelligence.ConsolidatedTestingHub'), \
             patch('TestMaster.core.intelligence.ConsolidatedIntegrationHub'):
            
            hub = IntelligenceHub()
            test_data = {'project_path': '/test/project'}
            
            # Act
            start_time = time.time()
            result = hub.analyze_comprehensive(test_data)
            end_time = time.time()
            
            # Assert
            response_time = end_time - start_time
            assert response_time < 5.0  # Should complete within 5 seconds
    
    @pytest.mark.performance
    def test_memory_usage_reasonable(self):
        """Test that memory usage stays within reasonable bounds"""
        # Arrange
        import psutil
        import gc
        
        process = psutil.Process()
        initial_memory = process.memory_info().rss
        
        with patch('TestMaster.core.intelligence.ConsolidatedAnalyticsHub'), \
             patch('TestMaster.core.intelligence.ConsolidatedTestingHub'), \
             patch('TestMaster.core.intelligence.ConsolidatedIntegrationHub'):
            
            hub = IntelligenceHub()
            
            # Act - Perform multiple analyses
            for i in range(10):
                test_data = {'project_path': f'/test/project_{i}'}
                result = hub.analyze_comprehensive(test_data)
                
                # Force garbage collection
                gc.collect()
            
            final_memory = process.memory_info().rss
            memory_increase = (final_memory - initial_memory) / (1024 * 1024)  # MB
            
            # Assert
            assert memory_increase < 100  # Should not increase by more than 100MB
    
    @pytest.mark.performance
    @pytest.mark.asyncio
    async def test_concurrent_analysis_handling(self):
        """Test that hub can handle concurrent analysis requests"""
        # Arrange
        with patch('TestMaster.core.intelligence.ConsolidatedAnalyticsHub'), \
             patch('TestMaster.core.intelligence.ConsolidatedTestingHub'), \
             patch('TestMaster.core.intelligence.ConsolidatedIntegrationHub'):
            
            hub = IntelligenceHub()
            
            # Act - Start multiple concurrent analyses
            tasks = []
            for i in range(5):
                test_data = {'project_path': f'/test/project_{i}'}
                task = asyncio.create_task(hub.analyze_comprehensive(test_data))
                tasks.append(task)
            
            # Wait for all to complete
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # Assert
            successful_results = [r for r in results if not isinstance(r, Exception)]
            assert len(successful_results) >= 3  # At least 3 should succeed


class TestIntelligenceHubIntegration:
    """Test Intelligence Hub integration with other components"""
    
    def test_api_endpoint_integration(self):
        """Test integration with REST API endpoints"""
        # Arrange
        with patch('TestMaster.core.intelligence.ConsolidatedAnalyticsHub'), \
             patch('TestMaster.core.intelligence.ConsolidatedTestingHub'), \
             patch('TestMaster.core.intelligence.ConsolidatedIntegrationHub'):
            
            hub = IntelligenceHub()
            
            # Mock API request
            api_request = {
                'endpoint': '/api/intelligence/analyze',
                'method': 'POST',
                'data': {'project_path': '/test/project'},
                'headers': {'Content-Type': 'application/json'}
            }
            
            # Act
            response = hub.handle_api_request(api_request)
            
            # Assert
            assert response is not None
            assert 'status' in response
            assert response['status'] in ['success', 'error']
    
    def test_database_integration(self):
        """Test integration with database for storing analysis results"""
        # Arrange
        with patch('TestMaster.core.intelligence.ConsolidatedAnalyticsHub'), \
             patch('TestMaster.core.intelligence.ConsolidatedTestingHub'), \
             patch('TestMaster.core.intelligence.ConsolidatedIntegrationHub'):
            
            hub = IntelligenceHub()
            test_data = {'project_path': '/test/project'}
            
            # Mock database operations
            with patch('TestMaster.database.analysis_storage') as mock_db:
                mock_db.save_analysis.return_value = {'id': 'analysis_123'}
                mock_db.load_analysis.return_value = {'status': 'completed'}
                
                # Act
                result = hub.analyze_and_store(test_data)
                
                # Assert
                assert mock_db.save_analysis.called
                assert 'id' in result
    
    def test_monitoring_integration(self):
        """Test integration with monitoring and alerting systems"""
        # Arrange
        with patch('TestMaster.core.intelligence.ConsolidatedAnalyticsHub'), \
             patch('TestMaster.core.intelligence.ConsolidatedTestingHub'), \
             patch('TestMaster.core.intelligence.ConsolidatedIntegrationHub'):
            
            hub = IntelligenceHub()
            
            # Mock monitoring system
            with patch('TestMaster.monitoring.metrics_collector') as mock_metrics:
                mock_metrics.record_analysis.return_value = True
                
                test_data = {'project_path': '/test/project'}
                
                # Act
                result = hub.analyze_comprehensive(test_data)
                
                # Assert
                assert mock_metrics.record_analysis.called
                call_args = mock_metrics.record_analysis.call_args[0]
                assert 'analysis_duration' in str(call_args)


# Error classes for testing
class SecurityError(Exception):
    """Security-related error"""
    pass

class AuthenticationError(Exception):
    """Authentication-related error"""
    pass

class RateLimitError(Exception):
    """Rate limiting error"""
    pass


if __name__ == "__main__":
    # Run the tests
    pytest.main([__file__, "-v", "--tb=short"])