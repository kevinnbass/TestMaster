<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Epsilon Modular Dashboard - Enhanced Intelligence</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #fff;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            padding: 40px 0;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            margin-bottom: 30px;
        }
        
        h1 {
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
        }
        
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .card h2 {
            margin-bottom: 20px;
            font-size: 1.5em;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 10px;
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .metric:last-child {
            border-bottom: none;
        }
        
        .metric-label {
            font-weight: 600;
            opacity: 0.9;
        }
        
        .metric-value {
            font-weight: bold;
            color: #ffd700;
        }
        
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-left: 10px;
        }
        
        .status-excellent { background: #4ade80; }
        .status-good { background: #facc15; }
        .status-needs_attention { background: #f87171; }
        
        .insights-container {
            margin-top: 20px;
        }
        
        .insight {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            border-left: 4px solid #ffd700;
        }
        
        .insight-type {
            font-size: 0.9em;
            opacity: 0.8;
            margin-bottom: 5px;
        }
        
        .insight-message {
            font-weight: 600;
            margin-bottom: 10px;
        }
        
        .recommendations {
            font-size: 0.9em;
            opacity: 0.9;
        }
        
        .recommendations ul {
            margin-left: 20px;
            margin-top: 5px;
        }
        
        #connectionStatus {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            font-size: 0.9em;
        }
        
        .connected { color: #4ade80; }
        .disconnected { color: #f87171; }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .loading {
            animation: pulse 2s infinite;
        }
        
        /* New API testing section */
        .api-testing {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
        }
        
        .api-button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            margin: 5px;
            transition: transform 0.2s ease;
        }
        
        .api-button:hover {
            transform: scale(1.05);
        }
        
        .api-response {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 0.9em;
            white-space: pre-wrap;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
</head>
<body>
    <div id="connectionStatus" class="disconnected">Connecting...</div>
    
    <div class="container">
        <header>
            <h1>ðŸš€ Epsilon Modular Dashboard</h1>
            <div class="subtitle">Enhanced Contextual Intelligence System - Hour 5 Modular Implementation</div>
        </header>
        
        <div class="dashboard-grid">
            <div class="card">
                <h2>ðŸ§  Contextual Intelligence</h2>
                <div id="contextualMetrics" class="loading">
                    <div class="metric">
                        <span class="metric-label">Correlations Detected</span>
                        <span class="metric-value" id="correlationsCount">0</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Insights Generated</span>
                        <span class="metric-value" id="insightsCount">0</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Predictions Made</span>
                        <span class="metric-value" id="predictionsCount">0</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Optimization Opportunities</span>
                        <span class="metric-value" id="optimizationCount">0</span>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <h2>ðŸ“Š Agent Coordination Health</h2>
                <div id="coordinationHealth" class="loading">
                    <div class="metric">
                        <span class="metric-label">Overall Health Score</span>
                        <span class="metric-value">
                            <span id="healthScore">--</span>%
                            <span id="healthStatus" class="status-indicator"></span>
                        </span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Data Synchronization</span>
                        <span class="metric-value" id="dataSync">--</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Response Consistency</span>
                        <span class="metric-value" id="responseConsistency">--</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Resource Balance</span>
                        <span class="metric-value" id="resourceBalance">--</span>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <h2>ðŸ’¡ Proactive Insights</h2>
                <div id="proactiveInsights" class="insights-container loading">
                    <div class="insight">
                        <div class="insight-type">Loading insights...</div>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <h2>ðŸŽ¯ User Behavior Predictions</h2>
                <div id="behaviorPredictions" class="loading">
                    <div class="metric">
                        <span class="metric-label">Next Likely Action</span>
                        <span class="metric-value" id="nextAction">--</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Information Need</span>
                        <span class="metric-value" id="infoNeed">--</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Attention Focus</span>
                        <span class="metric-value" id="attentionFocus">--</span>
                    </div>
                </div>
            </div>
            
            <!-- New Modular API Testing Card -->
            <div class="card">
                <h2>ðŸ”§ Modular APIs</h2>
                <div class="api-testing">
                    <h3>Test Modular Components:</h3>
                    <button class="api-button" onclick="testUnifiedData()">Test Data Integration</button>
                    <button class="api-button" onclick="testVisualizationRecs()">Test Viz Recommendations</button>
                    <button class="api-button" onclick="testChartConfig()">Test Chart Config</button>
                    <div id="apiResponse" class="api-response" style="display: none;"></div>
                </div>
            </div>
            
            <!-- Data Integration Card -->
            <div class="card">
                <h2>ðŸ“Š Unified Data Integration</h2>
                <div id="dataIntegration" class="loading">
                    <div class="metric">
                        <span class="metric-label">Data Sources</span>
                        <span class="metric-value" id="dataSources">--</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Intelligence Score</span>
                        <span class="metric-value" id="intelligenceScore">--</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Information Density</span>
                        <span class="metric-value" id="informationDensity">--</span>
                    </div>
                </div>
            </div>
            
            <!-- Performance Monitoring Card -->
            <div class="card">
                <h2>âš¡ Performance Monitor</h2>
                <div id="performanceMonitoring" class="loading">
                    <div class="metric">
                        <span class="metric-label">Performance Score</span>
                        <span class="metric-value">
                            <span id="performanceScore">--</span>
                            <span id="performanceStatus" class="status-indicator"></span>
                        </span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">CPU Usage</span>
                        <span class="metric-value" id="cpuUsage">--</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Memory Usage</span>
                        <span class="metric-value" id="memoryUsage">--</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">System Health</span>
                        <span class="metric-value" id="systemHealth">--</span>
                    </div>
                </div>
            </div>
            
            <!-- Hour 7: Advanced Visualization Intelligence Card -->
            <div class="card">
                <h2>ðŸ“Š Advanced Visualization Intelligence</h2>
                <div id="visualizationIntelligence" class="loading">
                    <div class="metric">
                        <span class="metric-label">AI Recommendations</span>
                        <span class="metric-value" id="aiRecommendations">--</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Layout Optimization</span>
                        <span class="metric-value" id="layoutOptimization">--</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Interactive Features</span>
                        <span class="metric-value" id="interactiveFeatures">--</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Data Quality Score</span>
                        <span class="metric-value">
                            <span id="dataQualityScore">--</span>
                            <span id="dataQualityStatus" class="status-indicator"></span>
                        </span>
                    </div>
                </div>
                
                <div class="api-testing">
                    <h3>Advanced Visualization Controls:</h3>
                    <button class="api-button" onclick="testInteractiveConfig()">Test Interactive Config</button>
                    <button class="api-button" onclick="testAdaptiveLayout()">Test Adaptive Layout</button>
                    <button class="api-button" onclick="testVisualizationInsights()">Get AI Insights</button>
                    <div id="visualizationResponse" class="api-response" style="display: none;"></div>
                </div>
            </div>
            
            <!-- Hour 8: Real-time Chart Visualization Card -->
            <div class="card" style="grid-column: span 2;">
                <h2>ðŸ“ˆ Real-time Performance Analytics</h2>
                <div class="api-testing" style="margin-bottom: 15px;">
                    <button class="api-button" onclick="startRealTimeStreaming()">Start Live Streaming</button>
                    <button class="api-button" onclick="stopRealTimeStreaming()">Stop Streaming</button>
                    <button class="api-button" onclick="requestPredictiveAnalysis()">Get Predictions</button>
                    <select id="chartTimeRange" onchange="updateChartRange()">
                        <option value="1h">Last Hour</option>
                        <option value="6h">Last 6 Hours</option>
                        <option value="24h">Last 24 Hours</option>
                    </select>
                </div>
                <div style="height: 400px; position: relative;">
                    <canvas id="realTimeChart"></canvas>
                </div>
                <div id="chartStatus" style="text-align: center; margin-top: 10px; font-size: 0.9em; opacity: 0.8;">
                    Chart Ready - Click "Start Live Streaming" to begin
                </div>
            </div>
            
            <!-- Hour 8: Predictive Analytics Card -->
            <div class="card">
                <h2>ðŸ”® Predictive Analytics</h2>
                <div id="predictiveAnalytics" class="loading">
                    <div class="metric">
                        <span class="metric-label">Next Hour Forecast</span>
                        <span class="metric-value" id="nextHourForecast">--</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Trend Direction</span>
                        <span class="metric-value" id="trendDirection">--</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Confidence Level</span>
                        <span class="metric-value">
                            <span id="confidenceLevel">--</span>
                            <span id="confidenceStatus" class="status-indicator"></span>
                        </span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Anomaly Risk</span>
                        <span class="metric-value" id="anomalyRisk">--</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        class ModularDashboard {
            constructor() {
                this.socket = io();
                this.realTimeChart = null;
                this.isStreaming = false;
                this.chartData = {
                    labels: [],
                    datasets: [{
                        label: 'Performance Score',
                        data: [],
                        borderColor: 'rgb(75, 192, 192)',
                        backgroundColor: 'rgba(75, 192, 192, 0.2)',
                        tension: 0.4
                    }, {
                        label: 'CPU Usage',
                        data: [],
                        borderColor: 'rgb(255, 99, 132)',
                        backgroundColor: 'rgba(255, 99, 132, 0.2)',
                        tension: 0.4
                    }, {
                        label: 'Memory Usage',
                        data: [],
                        borderColor: 'rgb(54, 162, 235)',
                        backgroundColor: 'rgba(54, 162, 235, 0.2)',
                        tension: 0.4
                    }]
                };
                this.predictiveData = null;
                this.setupEventHandlers();
                this.initializeDashboard();
                this.initializeRealTimeChart();
            }
            
            setupEventHandlers() {
                this.socket.on('connect', () => {
                    console.log('Connected to Modular Dashboard');
                    document.getElementById('connectionStatus').textContent = 'Connected';
                    document.getElementById('connectionStatus').className = 'connected';
                    this.requestInitialData();
                });
                
                this.socket.on('disconnect', () => {
                    console.log('Disconnected from dashboard');
                    document.getElementById('connectionStatus').textContent = 'Disconnected';
                    document.getElementById('connectionStatus').className = 'disconnected';
                });
                
                this.socket.on('analysis_result', (data) => {
                    this.updateContextualAnalysis(data.analysis);
                });
                
                // Hour 8: Real-time streaming event handlers
                this.socket.on('performance_stream', (data) => {
                    this.updateRealTimeChart(data.metrics);
                });
                
                this.socket.on('predictive_stream', (data) => {
                    this.updatePredictiveAnalytics(data.predictions);
                });
                
                this.socket.on('chart_data_update', (data) => {
                    this.handleChartDataUpdate(data);
                });
                
                this.socket.on('predictive_analysis_result', (data) => {
                    this.displayPredictiveAnalysis(data);
                });
            }
            
            async initializeDashboard() {
                // Fetch initial data via REST API
                await this.fetchHealthData();
                await this.fetchProactiveInsights();
                await this.fetchBehaviorPredictions();
                await this.fetchUnifiedData();
                await this.fetchPerformanceMetrics();
                await this.fetchVisualizationIntelligence();
                
                // Set up periodic updates
                setInterval(() => this.fetchHealthData(), 5000);
                setInterval(() => this.fetchProactiveInsights(), 10000);
                setInterval(() => this.fetchBehaviorPredictions(), 15000);
                setInterval(() => this.fetchUnifiedData(), 8000);
                setInterval(() => this.fetchPerformanceMetrics(), 3000);
                setInterval(() => this.fetchVisualizationIntelligence(), 12000);
            }
            
            requestInitialData() {
                // Request analysis via WebSocket
                const mockAgentData = {
                    'agent_alpha': {
                        'cpu_usage': 45,
                        'memory_usage': 62,
                        'response_time': 120,
                        'error_rate': 2
                    },
                    'agent_beta': {
                        'cpu_usage': 38,
                        'memory_usage': 55,
                        'response_time': 95,
                        'error_rate': 1
                    },
                    'agent_gamma': {
                        'cpu_usage': 72,
                        'memory_usage': 81,
                        'response_time': 250,
                        'error_rate': 4
                    }
                };
                
                this.socket.emit('request_analysis', { agent_data: mockAgentData });
            }
            
            async fetchHealthData() {
                try {
                    const response = await fetch('/api/health');
                    const data = await response.json();
                    
                    if (data.modules && data.modules.intelligence_metrics) {
                        const metrics = data.modules.intelligence_metrics;
                        document.getElementById('correlationsCount').textContent = metrics.correlations_detected;
                        document.getElementById('insightsCount').textContent = metrics.insights_generated;
                        document.getElementById('predictionsCount').textContent = metrics.predictions_made;
                        document.getElementById('optimizationCount').textContent = metrics.optimization_opportunities;
                    }
                    
                    // Remove loading state
                    document.getElementById('contextualMetrics').classList.remove('loading');
                } catch (error) {
                    console.error('Error fetching health data:', error);
                }
            }
            
            async fetchProactiveInsights() {
                try {
                    const response = await fetch('/api/proactive-insights');
                    const data = await response.json();
                    
                    const container = document.getElementById('proactiveInsights');
                    container.innerHTML = '';
                    container.classList.remove('loading');
                    
                    if (data.insights && data.insights.length > 0) {
                        data.insights.forEach(insight => {
                            const insightEl = document.createElement('div');
                            insightEl.className = 'insight';
                            insightEl.innerHTML = `
                                <div class="insight-type">${insight.type.replace('_', ' ').toUpperCase()}</div>
                                <div class="insight-message">${insight.message}</div>
                                ${insight.recommendations ? `
                                    <div class="recommendations">
                                        Recommendations:
                                        <ul>${insight.recommendations.map(r => `<li>${r}</li>`).join('')}</ul>
                                    </div>
                                ` : ''}
                            `;
                            container.appendChild(insightEl);
                        });
                    } else {
                        container.innerHTML = '<div class="insight"><div class="insight-type">All systems optimal</div></div>';
                    }
                } catch (error) {
                    console.error('Error fetching insights:', error);
                }
            }
            
            async fetchBehaviorPredictions() {
                try {
                    const response = await fetch('/api/behavior-prediction', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            user_context: { role: 'technical', device: 'desktop' },
                            history: [
                                { action: 'view_metrics', timestamp: Date.now() - 60000 },
                                { action: 'check_health', timestamp: Date.now() - 30000 },
                                { action: 'view_metrics', timestamp: Date.now() - 15000 }
                            ]
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.predictions) {
                        const predictions = data.predictions;
                        
                        // Update next action
                        if (predictions.next_likely_actions && predictions.next_likely_actions.length > 0) {
                            const topAction = predictions.next_likely_actions[0];
                            document.getElementById('nextAction').textContent = 
                                `${topAction.action} (${Math.round(topAction.probability * 100)}%)`;
                        }
                        
                        // Update information needs
                        if (predictions.information_needs && predictions.information_needs.length > 0) {
                            document.getElementById('infoNeed').textContent = 
                                predictions.information_needs[0].replace('_', ' ');
                        }
                        
                        // Update attention focus
                        document.getElementById('attentionFocus').textContent = 'Metrics & Health';
                    }
                    
                    document.getElementById('behaviorPredictions').classList.remove('loading');
                } catch (error) {
                    console.error('Error fetching predictions:', error);
                }
            }
            
            async fetchUnifiedData() {
                try {
                    const response = await fetch('/api/unified-data?role=technical&device=desktop');
                    const data = await response.json();
                    
                    if (data.data && data.data.intelligence_metadata) {
                        const metadata = data.data.intelligence_metadata;
                        document.getElementById('dataSources').textContent = '5 Active';
                        document.getElementById('intelligenceScore').textContent = 
                            `${(metadata.synthesis_quality * 100).toFixed(1)}%`;
                        document.getElementById('informationDensity').textContent = 
                            `${metadata.information_density.toFixed(0)}%`;
                    }
                    
                    document.getElementById('dataIntegration').classList.remove('loading');
                } catch (error) {
                    console.error('Error fetching unified data:', error);
                }
            }
            
            async fetchPerformanceMetrics() {
                try {
                    const response = await fetch('/api/performance-metrics');
                    const data = await response.json();
                    
                    if (data.metrics) {
                        const metrics = data.metrics;
                        
                        // Update performance score and status indicator
                        document.getElementById('performanceScore').textContent = 
                            `${Math.round(metrics.performance_score)}%`;
                        
                        const performanceStatusEl = document.getElementById('performanceStatus');
                        if (metrics.performance_score >= 80) {
                            performanceStatusEl.className = 'status-indicator status-excellent';
                        } else if (metrics.performance_score >= 60) {
                            performanceStatusEl.className = 'status-indicator status-good';
                        } else {
                            performanceStatusEl.className = 'status-indicator status-needs_attention';
                        }
                        
                        // Update system metrics
                        document.getElementById('cpuUsage').textContent = `${metrics.cpu_usage.toFixed(1)}%`;
                        document.getElementById('memoryUsage').textContent = `${metrics.memory_usage.toFixed(1)}%`;
                        document.getElementById('systemHealth').textContent = metrics.system_health;
                    }
                    
                    document.getElementById('performanceMonitoring').classList.remove('loading');
                } catch (error) {
                    console.error('Error fetching performance metrics:', error);
                    document.getElementById('performanceMonitoring').classList.remove('loading');
                }
            }
            
            async fetchVisualizationIntelligence() {
                try {
                    const response = await fetch('/api/visualization/intelligence-insights');
                    const data = await response.json();
                    
                    if (data.insights) {
                        const insights = data.insights;
                        
                        // Update AI recommendations count
                        document.getElementById('aiRecommendations').textContent = 
                            insights.recommendations ? insights.recommendations.length : '0';
                        
                        // Update layout optimization status
                        const optimizations = insights.optimizations || [];
                        document.getElementById('layoutOptimization').textContent = 
                            optimizations.length > 0 ? `${optimizations.length} Available` : 'Optimal';
                        
                        // Update interactive features count
                        const uxImprovements = insights.user_experience_improvements || [];
                        document.getElementById('interactiveFeatures').textContent = 
                            uxImprovements.length > 0 ? `${uxImprovements.length} Suggested` : 'Active';
                        
                        // Update data quality score
                        const dataQualityIssues = insights.data_quality_issues || [];
                        const qualityScore = Math.max(0, 100 - (dataQualityIssues.length * 20));
                        document.getElementById('dataQualityScore').textContent = `${qualityScore}%`;
                        
                        const qualityStatusEl = document.getElementById('dataQualityStatus');
                        if (qualityScore >= 80) {
                            qualityStatusEl.className = 'status-indicator status-excellent';
                        } else if (qualityScore >= 60) {
                            qualityStatusEl.className = 'status-indicator status-good';
                        } else {
                            qualityStatusEl.className = 'status-indicator status-needs_attention';
                        }
                    }
                    
                    document.getElementById('visualizationIntelligence').classList.remove('loading');
                } catch (error) {
                    console.error('Error fetching visualization intelligence:', error);
                    document.getElementById('visualizationIntelligence').classList.remove('loading');
                }
            }
            
            // Hour 8: Real-time Chart Integration Methods
            initializeRealTimeChart() {
                const ctx = document.getElementById('realTimeChart').getContext('2d');
                
                this.realTimeChart = new Chart(ctx, {
                    type: 'line',
                    data: this.chartData,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: {
                            duration: 750,
                            easing: 'easeInOutQuad'
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'minute',
                                    displayFormats: {
                                        minute: 'HH:mm'
                                    }
                                },
                                title: {
                                    display: true,
                                    text: 'Time'
                                }
                            },
                            y: {
                                beginAtZero: true,
                                max: 100,
                                title: {
                                    display: true,
                                    text: 'Percentage'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    afterBody: function(tooltipItems) {
                                        let total = 0;
                                        tooltipItems.forEach(function(tooltipItem) {
                                            total += tooltipItem.parsed.y;
                                        });
                                        return 'Combined Load: ' + (total / tooltipItems.length).toFixed(1) + '%';
                                    }
                                }
                            }
                        },
                        interaction: {
                            mode: 'nearest',
                            axis: 'x',
                            intersect: false
                        }
                    }
                });
            }
            
            updateRealTimeChart(metrics) {
                if (!this.realTimeChart || !this.isStreaming) return;
                
                const timestamp = new Date();
                const maxDataPoints = 50;
                
                // Add new data point
                this.chartData.labels.push(timestamp);
                this.chartData.datasets[0].data.push(metrics.performance_score || 0);
                this.chartData.datasets[1].data.push(metrics.cpu_usage || 0);
                this.chartData.datasets[2].data.push(metrics.memory_usage || 0);
                
                // Remove old data points if we exceed max
                if (this.chartData.labels.length > maxDataPoints) {
                    this.chartData.labels.shift();
                    this.chartData.datasets.forEach(dataset => dataset.data.shift());
                }
                
                // Update chart
                this.realTimeChart.update('none'); // No animation for real-time updates
                
                // Update chart status
                document.getElementById('chartStatus').textContent = 
                    `Live streaming - Last update: ${timestamp.toLocaleTimeString()}`;
            }
            
            updatePredictiveAnalytics(predictions) {
                if (!predictions.predictions || predictions.predictions.length === 0) return;
                
                const nextHour = predictions.predictions[0];
                const avgConfidence = predictions.confidence?.average || 0;
                
                // Update predictive metrics
                document.getElementById('nextHourForecast').textContent = 
                    `${Math.round(nextHour.predicted_value)}%`;
                
                // Determine trend direction
                const trend = predictions.confidence?.trend_strength > 0.5 ? 'Upward' : 'Stable';
                document.getElementById('trendDirection').textContent = trend;
                
                // Update confidence level
                document.getElementById('confidenceLevel').textContent = 
                    `${Math.round(avgConfidence * 100)}%`;
                    
                const confidenceStatusEl = document.getElementById('confidenceStatus');
                if (avgConfidence >= 0.8) {
                    confidenceStatusEl.className = 'status-indicator status-excellent';
                } else if (avgConfidence >= 0.6) {
                    confidenceStatusEl.className = 'status-indicator status-good';
                } else {
                    confidenceStatusEl.className = 'status-indicator status-needs_attention';
                }
                
                // Update anomaly risk
                const anomalyRisk = predictions.predictions.some(p => p.predicted_value > 90) ? 'High' : 'Low';
                document.getElementById('anomalyRisk').textContent = anomalyRisk;
                
                document.getElementById('predictiveAnalytics').classList.remove('loading');
            }
            
            handleChartDataUpdate(data) {
                if (data.chart_type === 'performance_line') {
                    // Handle historical data loading
                    this.loadHistoricalData(data);
                }
            }
            
            loadHistoricalData(data) {
                if (!this.realTimeChart || !data.data || !data.data.points) return;
                
                // Clear existing data
                this.chartData.labels = [];
                this.chartData.datasets.forEach(dataset => dataset.data = []);
                
                // Load historical points
                data.data.points.forEach(point => {
                    this.chartData.labels.push(new Date(point.timestamp));
                    // For historical data, we'll use the value for all datasets as demo
                    this.chartData.datasets[0].data.push(point.value);
                    this.chartData.datasets[1].data.push(point.value * 0.8);
                    this.chartData.datasets[2].data.push(point.value * 1.2);
                });
                
                this.realTimeChart.update();
                document.getElementById('chartStatus').textContent = 
                    `Historical data loaded (${data.data.points.length} points)`;
            }
            
            displayPredictiveAnalysis(data) {
                if (!this.realTimeChart) return;
                
                // Add prediction overlay to chart
                const predictions = data.predictions;
                if (predictions && predictions.length > 0) {
                    // Create prediction dataset
                    const predictionDataset = {
                        label: 'Forecast',
                        data: predictions.map(p => ({
                            x: new Date(p.timestamp),
                            y: p.predicted_value
                        })),
                        borderColor: 'rgba(255, 206, 84, 1)',
                        backgroundColor: 'rgba(255, 206, 84, 0.2)',
                        borderDash: [5, 5],
                        tension: 0.4
                    };
                    
                    // Add or update prediction dataset
                    const existingPredictionIndex = this.realTimeChart.data.datasets.findIndex(
                        ds => ds.label === 'Forecast'
                    );
                    
                    if (existingPredictionIndex >= 0) {
                        this.realTimeChart.data.datasets[existingPredictionIndex] = predictionDataset;
                    } else {
                        this.realTimeChart.data.datasets.push(predictionDataset);
                    }
                    
                    this.realTimeChart.update();
                }
            }
            
            updateContextualAnalysis(analysis) {
                if (!analysis) return;
                
                // Update coordination health
                if (analysis.agent_coordination_health) {
                    const health = analysis.agent_coordination_health;
                    document.getElementById('healthScore').textContent = health.overall_score;
                    
                    const statusEl = document.getElementById('healthStatus');
                    statusEl.className = `status-indicator status-${health.status}`;
                    
                    if (health.factors) {
                        document.getElementById('dataSync').textContent = 
                            `${Math.round(health.factors.data_synchronization)}%`;
                        document.getElementById('responseConsistency').textContent = 
                            `${Math.round(health.factors.response_time_consistency)}%`;
                        document.getElementById('resourceBalance').textContent = 
                            `${Math.round(health.factors.resource_utilization_balance)}%`;
                    }
                }
                
                document.getElementById('coordinationHealth').classList.remove('loading');
            }
        }
        
        // API Testing Functions
        async function testUnifiedData() {
            try {
                const response = await fetch('/api/unified-data?role=developer&device=desktop');
                const data = await response.json();
                showApiResponse('Unified Data Integration Test', data);
            } catch (error) {
                showApiResponse('Unified Data Integration Test', { error: error.message });
            }
        }
        
        async function testVisualizationRecs() {
            try {
                const response = await fetch('/api/visualization-recommendations', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        data_characteristics: {
                            volume: 150,
                            has_time_series: true,
                            correlation_count: 5,
                            has_hierarchy: false
                        },
                        user_context: { role: 'technical', device: 'desktop' }
                    })
                });
                const data = await response.json();
                showApiResponse('Visualization Recommendations Test', data);
            } catch (error) {
                showApiResponse('Visualization Recommendations Test', { error: error.message });
            }
        }
        
        async function testChartConfig() {
            try {
                const response = await fetch('/api/chart-config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chart_type: 'intelligent_line_chart',
                        data: { daily: true, hourly: true },
                        user_context: { role: 'analyst', device: 'desktop' },
                        enhancements: ['drill_down', 'smart_tooltips', 'trend_lines']
                    })
                });
                const data = await response.json();
                showApiResponse('Chart Configuration Test', data);
            } catch (error) {
                showApiResponse('Chart Configuration Test', { error: error.message });
            }
        }
        
        function showApiResponse(title, data) {
            const responseEl = document.getElementById('apiResponse');
            responseEl.style.display = 'block';
            responseEl.textContent = `${title}:\n${JSON.stringify(data, null, 2)}`;
        }
        
        function showVisualizationResponse(title, data) {
            const responseEl = document.getElementById('visualizationResponse');
            responseEl.style.display = 'block';
            responseEl.textContent = `${title}:\n${JSON.stringify(data, null, 2)}`;
        }
        
        // Hour 7: Advanced Visualization Testing Functions
        async function testInteractiveConfig() {
            try {
                const response = await fetch('/api/visualization/interactive-config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chart_type: 'intelligent_dashboard',
                        data_sources: [
                            { type: 'performance_metrics', volume: 100 },
                            { type: 'user_behavior', volume: 250 }
                        ],
                        user_context: { role: 'analyst', device: 'desktop' },
                        interactions: ['drill_down', 'smart_tooltips', 'correlation_highlights']
                    })
                });
                const data = await response.json();
                showVisualizationResponse('Interactive Configuration Test', data);
            } catch (error) {
                showVisualizationResponse('Interactive Configuration Test', { error: error.message });
            }
        }
        
        async function testAdaptiveLayout() {
            try {
                const response = await fetch('/api/visualization/adaptive-layout', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        device_info: { 
                            type: 'desktop', 
                            screen_size: 'large',
                            viewport: { width: 1920, height: 1080 }
                        },
                        preferences: { 
                            compact_mode: false, 
                            high_contrast: false,
                            animation_enabled: true
                        },
                        dashboard_data: {
                            component_count: 8,
                            data_complexity: 'medium',
                            update_frequency: 'high'
                        }
                    })
                });
                const data = await response.json();
                showVisualizationResponse('Adaptive Layout Test', data);
            } catch (error) {
                showVisualizationResponse('Adaptive Layout Test', { error: error.message });
            }
        }
        
        async function testVisualizationInsights() {
            try {
                const response = await fetch('/api/visualization/intelligence-insights');
                const data = await response.json();
                showVisualizationResponse('Visualization AI Insights', data);
            } catch (error) {
                showVisualizationResponse('Visualization AI Insights', { error: error.message });
            }
        }
        
        // Hour 8: Real-time Streaming Control Functions
        function startRealTimeStreaming() {
            const dashboard = window.dashboard;
            if (!dashboard.isStreaming) {
                dashboard.isStreaming = true;
                dashboard.socket.emit('subscribe_live_data', {
                    streams: ['performance_metrics', 'predictive_analytics']
                });
                
                // Load initial historical data
                dashboard.socket.emit('request_chart_data', {
                    chart_type: 'performance_line',
                    range: document.getElementById('chartTimeRange').value,
                    filters: {}
                });
                
                document.getElementById('chartStatus').textContent = 'Starting live stream...';
                console.log('Real-time streaming started');
            }
        }
        
        function stopRealTimeStreaming() {
            const dashboard = window.dashboard;
            if (dashboard.isStreaming) {
                dashboard.isStreaming = false;
                document.getElementById('chartStatus').textContent = 'Streaming stopped';
                console.log('Real-time streaming stopped');
            }
        }
        
        function updateChartRange() {
            const dashboard = window.dashboard;
            const range = document.getElementById('chartTimeRange').value;
            
            // Request new data for the selected range
            dashboard.socket.emit('request_chart_data', {
                chart_type: 'performance_line',
                range: range,
                filters: {}
            });
            
            document.getElementById('chartStatus').textContent = `Loading ${range} data...`;
        }
        
        function requestPredictiveAnalysis() {
            const dashboard = window.dashboard;
            dashboard.socket.emit('request_predictive_analysis', {
                type: 'trend_forecast',
                historical_data: {
                    performance_metrics: dashboard.chartData.datasets[0].data.slice(-10),
                    cpu_usage: dashboard.chartData.datasets[1].data.slice(-10),
                    memory_usage: dashboard.chartData.datasets[2].data.slice(-10)
                },
                horizon: 12
            });
            
            document.getElementById('chartStatus').textContent = 'Generating predictive analysis...';
        }
        
        // Initialize dashboard when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.dashboard = new ModularDashboard();
        });
    </script>
</body>
</html>