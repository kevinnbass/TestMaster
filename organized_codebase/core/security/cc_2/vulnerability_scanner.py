"""
Security Vulnerability Scanner Module
Extracted from enhanced_intelligence_linkage.py for Agent X's Epsilon base integration
< 200 lines per STEELCLAD protocol

Provides comprehensive security vulnerability assessment:
- Code vulnerability pattern detection
- Security pattern analysis
- Risk level calculation
- Vulnerability weight assessment
"""

import re
import logging
from typing import Dict, Any, List, Tuple
from dataclasses import dataclass
from enum import Enum

logger = logging.getLogger(__name__)

class VulnerabilityType(Enum):
    SQL_INJECTION = "sql_injection"
    XSS = "xss"
    HARDCODED_SECRETS = "hardcoded_secrets"
    UNSAFE_DESERIALIZATION = "unsafe_deserialization"
    WEAK_CRYPTO = "weak_crypto"
    INSECURE_RANDOM = "insecure_random"
    PATH_TRAVERSAL = "path_traversal"

class RiskLevel(Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

@dataclass
class VulnerabilityResult:
    """Vulnerability assessment result"""
    vulnerability_type: VulnerabilityType
    count: int
    weight: float
    risk_contribution: float
    pattern_matches: List[str]

@dataclass
class SecurityAssessment:
    """Complete security assessment result"""
    total_score: float
    risk_level: RiskLevel
    vulnerabilities: List[VulnerabilityResult]
    security_patterns: Dict[str, int]
    recommendations: List[str]
    scan_timestamp: str

class SecurityVulnerabilityScanner:
    """Pluggable security vulnerability scanning module"""
    
    def __init__(self):
        self.vulnerability_patterns = {
            VulnerabilityType.SQL_INJECTION: [
                r"execute\(.*\+",
                r"query\(.*\+", 
                r"\.format\(.*sql",
                r"SELECT.*\+",
                r"INSERT.*\+",
                r"UPDATE.*\+"
            ],
            VulnerabilityType.XSS: [
                r"innerHTML",
                r"document\.write",
                r"eval\(",
                r"outerHTML",
                r"insertAdjacentHTML"
            ],
            VulnerabilityType.HARDCODED_SECRETS: [
                r"password\s*=\s*[\"'][^\"']{6,}[\"']",
                r"api_key\s*=\s*[\"'][^\"']+[\"']",
                r"secret_key\s*=\s*[\"'][^\"']+[\"']",
                r"token\s*=\s*[\"'][^\"']{20,}[\"']"
            ],
            VulnerabilityType.UNSAFE_DESERIALIZATION: [
                r"pickle\.load",
                r"yaml\.load",
                r"eval\(",
                r"exec\(",
                r"marshal\.load"
            ],
            VulnerabilityType.WEAK_CRYPTO: [
                r"\bmd5\b",
                r"\bsha1\b",
                r"DES\(",
                r"RC4\(",
                r"random\.random\("
            ],
            VulnerabilityType.PATH_TRAVERSAL: [
                r"\.\./",
                r"os\.path\.join.*\.\.",
                r"file_path.*\.\.",
                r"open\(.*\.\."
            ]
        }
        
        self.vulnerability_weights = {
            VulnerabilityType.SQL_INJECTION: 8.0,
            VulnerabilityType.XSS: 6.5,
            VulnerabilityType.HARDCODED_SECRETS: 9.0,
            VulnerabilityType.UNSAFE_DESERIALIZATION: 8.5,
            VulnerabilityType.WEAK_CRYPTO: 5.5,
            VulnerabilityType.PATH_TRAVERSAL: 7.0
        }
        
        self.security_pattern_indicators = {
            "input_validation": [r"validate", r"sanitize", r"escape", r"clean", r"filter"],
            "error_handling": [r"try:", r"except", r"finally:", r"catch", r"error"],
            "logging": [r"log\.", r"logger\.", r"logging\.", r"audit"],
            "authentication": [r"auth", r"login", r"token", r"credential", r"verify"],
            "encryption": [r"encrypt", r"decrypt", r"cipher", r"hash", r"crypto"]
        }
    
    def scan_content_vulnerabilities(self, content: str, filename: str = None) -> SecurityAssessment:
        """Perform comprehensive vulnerability scan on content"""
        vulnerabilities = []
        total_score = 0.0
        
        # Scan for each vulnerability type
        for vuln_type, patterns in self.vulnerability_patterns.items():
            vuln_result = self._assess_vulnerability_type(content, vuln_type, patterns)
            vulnerabilities.append(vuln_result)
            total_score += vuln_result.risk_contribution
        
        # Analyze security patterns
        security_patterns = self._analyze_security_patterns(content)
        
        # Calculate risk level
        risk_level = self._calculate_risk_level(total_score)
        
        # Generate recommendations
        recommendations = self._generate_recommendations(vulnerabilities, security_patterns)
        
        from datetime import datetime
        return SecurityAssessment(
            total_score=total_score,
            risk_level=risk_level,
            vulnerabilities=vulnerabilities,
            security_patterns=security_patterns,
            recommendations=recommendations,
            scan_timestamp=datetime.now().isoformat()
        )
    
    def _assess_vulnerability_type(self, content: str, vuln_type: VulnerabilityType, patterns: List[str]) -> VulnerabilityResult:
        """Assess specific vulnerability type"""
        matches = []
        total_count = 0
        
        for pattern in patterns:
            pattern_matches = re.findall(pattern, content, re.IGNORECASE | re.MULTILINE)
            matches.extend(pattern_matches)
            total_count += len(pattern_matches)
        
        weight = self.vulnerability_weights.get(vuln_type, 5.0)
        risk_contribution = total_count * weight
        
        return VulnerabilityResult(
            vulnerability_type=vuln_type,
            count=total_count,
            weight=weight,
            risk_contribution=risk_contribution,
            pattern_matches=matches[:10]  # Limit to first 10 matches
        )
    
    def _analyze_security_patterns(self, content: str) -> Dict[str, int]:
        """Analyze positive security patterns"""
        security_patterns = {}
        
        for pattern_type, indicators in self.security_pattern_indicators.items():
            count = 0
            for indicator in indicators:
                count += len(re.findall(indicator, content, re.IGNORECASE))
            security_patterns[pattern_type] = count
        
        return security_patterns
    
    def _calculate_risk_level(self, total_score: float) -> RiskLevel:
        """Calculate overall risk level from total score"""
        if total_score >= 50:
            return RiskLevel.CRITICAL
        elif total_score >= 25:
            return RiskLevel.HIGH
        elif total_score >= 10:
            return RiskLevel.MEDIUM
        else:
            return RiskLevel.LOW
    
    def _generate_recommendations(self, vulnerabilities: List[VulnerabilityResult], security_patterns: Dict[str, int]) -> List[str]:
        """Generate security recommendations based on scan results"""
        recommendations = []
        
        # Vulnerability-based recommendations
        for vuln in vulnerabilities:
            if vuln.count > 0:
                recommendations.extend(self._get_vuln_recommendations(vuln.vulnerability_type))
        
        # Pattern-based recommendations
        if security_patterns.get("input_validation", 0) < 2:
            recommendations.append("Implement comprehensive input validation")
        
        if security_patterns.get("error_handling", 0) < 3:
            recommendations.append("Add proper error handling throughout code")
        
        if security_patterns.get("logging", 0) < 2:
            recommendations.append("Implement security event logging")
        
        if security_patterns.get("authentication", 0) == 0:
            recommendations.append("Consider adding authentication mechanisms")
        
        # Remove duplicates and limit to 8 recommendations
        return list(dict.fromkeys(recommendations))[:8]
    
    def _get_vuln_recommendations(self, vuln_type: VulnerabilityType) -> List[str]:
        """Get specific recommendations for vulnerability type"""
        recommendations_map = {
            VulnerabilityType.SQL_INJECTION: ["Use parameterized queries", "Implement SQL injection protection"],
            VulnerabilityType.XSS: ["Sanitize user input", "Use safe DOM manipulation methods"],
            VulnerabilityType.HARDCODED_SECRETS: ["Move secrets to environment variables", "Use secure secret management"],
            VulnerabilityType.UNSAFE_DESERIALIZATION: ["Validate deserialization input", "Use safe serialization formats"],
            VulnerabilityType.WEAK_CRYPTO: ["Use strong cryptographic algorithms", "Update to secure hash functions"],
            VulnerabilityType.PATH_TRAVERSAL: ["Validate file paths", "Use secure path handling methods"]
        }
        
        return recommendations_map.get(vuln_type, ["Review security implementation"])
    
    def scan_multiple_files(self, file_contents: Dict[str, str]) -> Dict[str, SecurityAssessment]:
        """Scan multiple files for vulnerabilities"""
        results = {}
        
        for filename, content in file_contents.items():
            results[filename] = self.scan_content_vulnerabilities(content, filename)
        
        return results
    
    def get_summary_report(self, assessments: List[SecurityAssessment]) -> Dict[str, Any]:
        """Generate summary report from multiple assessments"""
        if not assessments:
            return {"status": "no_assessments", "summary": {}}
        
        total_files = len(assessments)
        risk_distribution = {level.value: 0 for level in RiskLevel}
        total_vulnerabilities = 0
        
        for assessment in assessments:
            risk_distribution[assessment.risk_level.value] += 1
            total_vulnerabilities += sum(v.count for v in assessment.vulnerabilities)
        
        return {
            "status": "scan_complete",
            "summary": {
                "files_scanned": total_files,
                "total_vulnerabilities": total_vulnerabilities,
                "risk_distribution": risk_distribution,
                "avg_score": sum(a.total_score for a in assessments) / total_files if total_files > 0 else 0
            }
        }

# Plugin interface for Agent X integration
def create_vulnerability_scanner_plugin(config: Dict[str, Any] = None):
    """Factory function to create security vulnerability scanner plugin"""
    return SecurityVulnerabilityScanner()