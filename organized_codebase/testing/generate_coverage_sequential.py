#!/usr/bin/env python3
"""
Generate Test Coverage Sequentially
====================================

Generate tests one by one to achieve 100% coverage using Gemini 2.5 Pro.
Sequential approach for more reliable execution.
"""

import os
import sys
import json
import time
import subprocess
from pathlib import Path
from typing import Set

# Load environment
def load_env():
    env_file = Path(__file__).parent.parent.parent / '.env'
    if env_file.exists():
        with open(env_file, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    os.environ[key.strip()] = value.strip()

load_env()

from google import genai
from google.genai import types

class SequentialTestGenerator:
    """Generate tests sequentially with Gemini 2.5 Pro."""
    
    def __init__(self):
        self.api_key = os.getenv('GOOGLE_API_KEY')
        self.client = genai.Client(api_key=self.api_key) if self.api_key else None
        self.model_name = "gemini-2.5-pro"
        self.src_dir = Path("src_new")
        self.test_dir = Path("tests_new")
        self.test_dir.mkdir(exist_ok=True)
        
    def get_uncovered_modules(self) -> list:
        """Get list of modules that need tests."""
        print("Finding modules that need tests...")
        
        # Get all Python files in src_new
        src_files = list(self.src_dir.rglob("*.py"))
        
        # Filter out __init__ and __pycache__
        modules = []
        for src_file in src_files:
            if '__pycache__' in str(src_file) or '__init__' in src_file.name:
                continue
            
            # Check if test already exists
            test_name = f"test_{src_file.stem}_gemini.py"
            test_path = self.test_dir / test_name
            
            if not test_path.exists():
                modules.append(src_file)
        
        print(f"Found {len(modules)} modules needing tests")
        return modules
    
    def generate_test_for_module(self, src_file: Path) -> bool:
        """Generate test for a single module."""
        module_name = src_file.stem
        print(f"\nGenerating test for {module_name}...")
        
        # Read source code
        try:
            with open(src_file, 'r', encoding='utf-8') as f:
                source_code = f.read()[:5000]  # Limit to 5000 chars
        except Exception as e:
            print(f"  ERROR: Could not read {src_file}: {e}")
            return False
        
        # Create prompt
        prompt = f"""Generate comprehensive pytest tests for this Python module to achieve 100% code coverage.

Module: {module_name}.py
Code:
```python
{source_code}
```

Requirements:
1. Test ALL functions and classes
2. Test all branches (if/else, try/except)
3. Test edge cases and error conditions
4. Use mocks for external dependencies
5. Include proper imports

Output ONLY Python test code starting with:
```python
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent.parent / "src_new"))

import pytest
from unittest.mock import Mock, AsyncMock, patch
```
"""
        
        # Call Gemini 2.5 Pro
        if not self.client:
            print("  ERROR: No API client")
            return False
        
        try:
            print(f"  Calling Gemini 2.5 Pro...")
            response = self.client.models.generate_content(
                model=self.model_name,
                contents=prompt,
                config=types.GenerateContentConfig(
                    temperature=0.3,
                    max_output_tokens=8000
                )
            )
            
            if response and response.text:
                # Extract code
                text = response.text
                if '```python' in text:
                    parts = text.split('```python')
                    if len(parts) > 1:
                        code = parts[1].split('```')[0]
                    else:
                        code = text
                else:
                    code = text
                
                # Save test file
                test_file = self.test_dir / f"test_{module_name}_gemini.py"
                
                # Add header
                final_code = f'''#!/usr/bin/env python3
"""
Tests for {module_name} module
Generated by Gemini 2.5 Pro for 100% coverage
"""

{code}
'''
                
                test_file.write_text(final_code, encoding='utf-8')
                print(f"  [OK] Saved {test_file.name}")
                return True
            else:
                print(f"  ERROR: No response from Gemini")
                return False
                
        except Exception as e:
            print(f"  ERROR: {e}")
            return False
    
    def measure_coverage(self) -> float:
        """Measure current test coverage."""
        print("\nMeasuring coverage...")
        
        try:
            result = subprocess.run(
                ['python', '-m', 'pytest', 'tests_new',
                 '--cov=src_new', '--cov-report=term',
                 '--tb=no', '-q', '--disable-warnings'],
                capture_output=True,
                text=True,
                timeout=60
            )
            
            # Extract coverage percentage
            for line in result.stdout.split('\n'):
                if 'TOTAL' in line:
                    parts = line.split()
                    if len(parts) >= 4:
                        try:
                            coverage = float(parts[-1].rstrip('%'))
                            return coverage
                        except:
                            pass
        except Exception as e:
            print(f"ERROR measuring coverage: {e}")
        
        return 0.0
    
    def run(self, limit: int = None):
        """Run sequential test generation."""
        print("=" * 70)
        print("SEQUENTIAL TEST GENERATION WITH GEMINI 2.5 PRO")
        print(f"Model: {self.model_name}")
        print("Rate: 30 RPM (2 second delay between requests)")
        print("=" * 70)
        
        # Check API key
        if not self.api_key:
            print("\nERROR: GOOGLE_API_KEY not set")
            return
        
        print(f"\n[OK] API key configured")
        
        # Get initial coverage
        initial_coverage = self.measure_coverage()
        print(f"Initial coverage: {initial_coverage:.2f}%")
        
        # Get modules needing tests
        modules = self.get_uncovered_modules()
        
        if limit:
            modules = modules[:limit]
            print(f"Limiting to {limit} modules")
        
        # Generate tests sequentially
        generated = 0
        errors = 0
        
        for i, module in enumerate(modules):
            print(f"\n[{i+1}/{len(modules)}] Processing {module.name}")
            
            success = self.generate_test_for_module(module)
            
            if success:
                generated += 1
            else:
                errors += 1
            
            # Rate limiting: 30 RPM = 1 request every 2 seconds
            if i < len(modules) - 1:  # Don't wait after last request
                print("  Waiting 2 seconds for rate limit...")
                time.sleep(2)
        
        print("\n" + "=" * 70)
        print("GENERATION COMPLETE")
        print("=" * 70)
        print(f"Generated: {generated} test files")
        print(f"Errors: {errors}")
        
        # Measure final coverage
        if generated > 0:
            final_coverage = self.measure_coverage()
            print(f"\nInitial coverage: {initial_coverage:.2f}%")
            print(f"Final coverage: {final_coverage:.2f}%")
            print(f"Improvement: +{final_coverage - initial_coverage:.2f}%")
            
            if final_coverage == 100.0:
                print("\nSUCCESS! 100% COVERAGE ACHIEVED!")
            elif final_coverage > initial_coverage:
                print(f"\nProgress made! Continue running to reach 100%")
            else:
                print(f"\nNo improvement. Check generated tests for errors.")

def main():
    """Main function."""
    import argparse
    
    parser = argparse.ArgumentParser(description='Generate tests sequentially')
    parser.add_argument('--limit', type=int, help='Limit number of modules to process')
    args = parser.parse_args()
    
    generator = SequentialTestGenerator()
    generator.run(limit=args.limit)
    
    return 0

if __name__ == "__main__":
    sys.exit(main())