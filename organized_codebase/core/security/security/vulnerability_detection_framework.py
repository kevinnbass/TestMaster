"""
Vulnerability Detection Framework - PHASE 3.2

Comprehensive enterprise-grade vulnerability detection system combining 
static analysis, dynamic analysis, and machine learning for advanced threat detection.
"""

import sqlite3
import json
import hashlib
import time
import threading
import ast
import re
from datetime import datetime, timedelta
from dataclasses import dataclass, asdict
from threading import RLock
from typing import Dict, List, Optional, Any, Set, Tuple, Union
from enum import Enum
from pathlib import Path
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# SQLite Database Schema
VULNERABILITY_DETECTION_SCHEMA = '''
CREATE TABLE IF NOT EXISTS vulnerability_patterns (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    pattern_name TEXT NOT NULL UNIQUE,
    pattern_type TEXT NOT NULL,
    pattern_data TEXT NOT NULL,
    severity TEXT NOT NULL,
    confidence REAL DEFAULT 1.0,
    cwe_id TEXT,
    owasp_category TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS scan_sessions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    session_id TEXT NOT NULL UNIQUE,
    scan_type TEXT NOT NULL,
    target_path TEXT NOT NULL,
    status TEXT DEFAULT 'running',
    total_files INTEGER DEFAULT 0,
    processed_files INTEGER DEFAULT 0,
    vulnerabilities_found INTEGER DEFAULT 0,
    started_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP,
    metadata TEXT
);

CREATE TABLE IF NOT EXISTS vulnerabilities (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    session_id TEXT NOT NULL,
    vulnerability_id TEXT NOT NULL UNIQUE,
    category TEXT NOT NULL,
    severity TEXT NOT NULL,
    confidence REAL NOT NULL,
    file_path TEXT NOT NULL,
    line_number INTEGER,
    column_number INTEGER,
    code_snippet TEXT,
    description TEXT NOT NULL,
    recommendation TEXT NOT NULL,
    cwe_id TEXT,
    owasp_category TEXT,
    cvss_score REAL,
    remediation_effort TEXT,
    false_positive BOOLEAN DEFAULT FALSE,
    verified BOOLEAN DEFAULT FALSE,
    discovered_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    metadata TEXT
);

CREATE TABLE IF NOT EXISTS vulnerability_trends (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    vulnerability_type TEXT NOT NULL,
    severity TEXT NOT NULL,
    count INTEGER NOT NULL,
    scan_date DATE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
'''

class VulnerabilityCategory(Enum):
    """Vulnerability categories based on OWASP and CWE."""
    INJECTION = "injection"
    BROKEN_AUTHENTICATION = "broken_authentication"
    SENSITIVE_DATA_EXPOSURE = "sensitive_data_exposure"
    XML_EXTERNAL_ENTITIES = "xml_external_entities"
    BROKEN_ACCESS_CONTROL = "broken_access_control"
    SECURITY_MISCONFIGURATION = "security_misconfiguration"
    CROSS_SITE_SCRIPTING = "cross_site_scripting"
    INSECURE_DESERIALIZATION = "insecure_deserialization"
    VULNERABLE_COMPONENTS = "vulnerable_components"
    INSUFFICIENT_LOGGING = "insufficient_logging"
    CRYPTOGRAPHIC_FAILURES = "cryptographic_failures"
    CODE_QUALITY = "code_quality"

class VulnerabilitySeverity(Enum):
    """Vulnerability severity levels."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

class ScanType(Enum):
    """Scan types."""
    STATIC = "static"
    DYNAMIC = "dynamic"
    DEPENDENCY = "dependency"
    CONFIGURATION = "configuration"
    COMPREHENSIVE = "comprehensive"

class PatternType(Enum):
    """Pattern types for vulnerability detection."""
    REGEX = "regex"
    AST = "ast"
    SEMANTIC = "semantic"
    BEHAVIORAL = "behavioral"

@dataclass
class VulnerabilityPattern:
    """Vulnerability detection pattern."""
    pattern_name: str
    pattern_type: PatternType
    pattern_data: Dict[str, Any]
    severity: VulnerabilitySeverity
    confidence: float
    cwe_id: Optional[str] = None
    owasp_category: Optional[str] = None
    id: Optional[int] = None

@dataclass
class Vulnerability:
    """Security vulnerability."""
    vulnerability_id: str
    category: VulnerabilityCategory
    severity: VulnerabilitySeverity
    confidence: float
    file_path: str
    line_number: Optional[int]
    column_number: Optional[int]
    code_snippet: Optional[str]
    description: str
    recommendation: str
    cwe_id: Optional[str] = None
    owasp_category: Optional[str] = None
    cvss_score: Optional[float] = None
    remediation_effort: Optional[str] = None
    false_positive: bool = False
    verified: bool = False
    metadata: Dict[str, Any] = None
    id: Optional[int] = None
    discovered_at: Optional[datetime] = None

@dataclass
class ScanSession:
    """Vulnerability scan session."""
    session_id: str
    scan_type: ScanType
    target_path: str
    status: str = "running"
    total_files: int = 0
    processed_files: int = 0
    vulnerabilities_found: int = 0
    metadata: Dict[str, Any] = None
    id: Optional[int] = None
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None

class StaticAnalyzer:
    """Static code analysis engine."""
    
    def __init__(self):
        self.patterns = self._load_builtin_patterns()
    
    def analyze_file(self, file_path: str) -> List[Vulnerability]:
        """Analyze a single file for vulnerabilities."""
        vulnerabilities = []
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # AST analysis for Python files
            if file_path.endswith('.py'):
                tree = ast.parse(content)
                vulnerabilities.extend(self._analyze_ast(tree, file_path, content))
            
            # Pattern-based analysis
            vulnerabilities.extend(self._analyze_patterns(content, file_path))
            
            # Specific vulnerability checks
            vulnerabilities.extend(self._check_injection_vulnerabilities(content, file_path))
            vulnerabilities.extend(self._check_crypto_vulnerabilities(content, file_path))
            vulnerabilities.extend(self._check_auth_vulnerabilities(content, file_path))
            vulnerabilities.extend(self._check_data_exposure(content, file_path))
            
        except Exception as e:
            logger.error(f"Error analyzing {file_path}: {e}")
        
        return vulnerabilities
    
    def _analyze_ast(self, tree: ast.AST, file_path: str, content: str) -> List[Vulnerability]:
        """Analyze AST for security vulnerabilities."""
        vulnerabilities = []
        
        for node in ast.walk(tree):
            # Check for dangerous function calls
            if isinstance(node, ast.Call):
                vulnerabilities.extend(self._check_dangerous_calls(node, file_path))
            
            # Check for insecure imports
            elif isinstance(node, ast.Import) or isinstance(node, ast.ImportFrom):
                vulnerabilities.extend(self._check_insecure_imports(node, file_path))
            
            # Check for hardcoded secrets
            elif isinstance(node, ast.Str):
                vulnerabilities.extend(self._check_hardcoded_secrets(node, file_path))
        
        return vulnerabilities
    
    def _check_dangerous_calls(self, node: ast.Call, file_path: str) -> List[Vulnerability]:
        """Check for dangerous function calls."""
        vulnerabilities = []
        
        dangerous_functions = {
            'eval': (VulnerabilitySeverity.CRITICAL, VulnerabilityCategory.INJECTION),
            'exec': (VulnerabilitySeverity.CRITICAL, VulnerabilityCategory.INJECTION),
            'compile': (VulnerabilitySeverity.HIGH, VulnerabilityCategory.INJECTION),
            'input': (VulnerabilitySeverity.MEDIUM, VulnerabilityCategory.INJECTION),
            '__import__': (VulnerabilitySeverity.HIGH, VulnerabilityCategory.INJECTION)
        }
        
        func_name = None
        if isinstance(node.func, ast.Name):
            func_name = node.func.id
        elif isinstance(node.func, ast.Attribute):
            if isinstance(node.func.value, ast.Name):
                func_name = f"{node.func.value.id}.{node.func.attr}"
        
        if func_name in dangerous_functions:
            severity, category = dangerous_functions[func_name]
            vuln_id = hashlib.sha256(f"{file_path}:{node.lineno}:{func_name}".encode()).hexdigest()[:16]
            
            vulnerabilities.append(Vulnerability(
                vulnerability_id=vuln_id,
                category=category,
                severity=severity,
                confidence=0.9,
                file_path=file_path,
                line_number=node.lineno,
                column_number=getattr(node, 'col_offset', None),
                description=f"Use of dangerous function '{func_name}'",
                recommendation=f"Avoid using '{func_name}' with untrusted input. Consider safer alternatives.",
                cwe_id="CWE-94",
                owasp_category="A03:2021"
            ))
        
        return vulnerabilities
    
    def _check_injection_vulnerabilities(self, content: str, file_path: str) -> List[Vulnerability]:
        """Check for injection vulnerabilities."""
        vulnerabilities = []
        
        # SQL injection patterns
        sql_patterns = [
            (r'execute\s*\(\s*["\'].*%[s|d].*["\'].*%', "SQL injection via string formatting"),
            (r'execute\s*\(\s*f["\'].*{.*}', "SQL injection via f-strings"),
            (r'cursor\.execute\s*\(\s*["\'].*\+', "SQL injection via string concatenation"),
            (r'\.format\s*\(\s*.*\)\s*\).*execute', "SQL injection via format method")
        ]
        
        for pattern, description in sql_patterns:
            for match in re.finditer(pattern, content, re.IGNORECASE):
                line_num = content[:match.start()].count('\n') + 1
                vuln_id = hashlib.sha256(f"{file_path}:{line_num}:sql_injection".encode()).hexdigest()[:16]
                
                vulnerabilities.append(Vulnerability(
                    vulnerability_id=vuln_id,
                    category=VulnerabilityCategory.INJECTION,
                    severity=VulnerabilitySeverity.CRITICAL,
                    confidence=0.8,
                    file_path=file_path,
                    line_number=line_num,
                    description=description,
                    recommendation="Use parameterized queries or prepared statements",
                    cwe_id="CWE-89",
                    owasp_category="A03:2021"
                ))
        
        return vulnerabilities
    
    def _check_crypto_vulnerabilities(self, content: str, file_path: str) -> List[Vulnerability]:
        """Check for cryptographic vulnerabilities."""
        vulnerabilities = []
        
        # Weak cryptographic patterns
        crypto_patterns = [
            (r'hashlib\.md5\s*\(', "Use of weak MD5 hash", VulnerabilitySeverity.HIGH),
            (r'hashlib\.sha1\s*\(', "Use of weak SHA1 hash", VulnerabilitySeverity.MEDIUM),
            (r'random\.random\(\)', "Use of weak random for security", VulnerabilitySeverity.MEDIUM),
            (r'DES\.new\s*\(', "Use of weak DES encryption", VulnerabilitySeverity.CRITICAL),
            (r'RC4\.new\s*\(', "Use of weak RC4 encryption", VulnerabilitySeverity.CRITICAL)
        ]
        
        for pattern, description, severity in crypto_patterns:
            for match in re.finditer(pattern, content):
                line_num = content[:match.start()].count('\n') + 1
                vuln_id = hashlib.sha256(f"{file_path}:{line_num}:crypto".encode()).hexdigest()[:16]
                
                vulnerabilities.append(Vulnerability(
                    vulnerability_id=vuln_id,
                    category=VulnerabilityCategory.CRYPTOGRAPHIC_FAILURES,
                    severity=severity,
                    confidence=0.9,
                    file_path=file_path,
                    line_number=line_num,
                    description=description,
                    recommendation="Use strong cryptographic algorithms (SHA-256, AES, etc.)",
                    cwe_id="CWE-327",
                    owasp_category="A02:2021"
                ))
        
        return vulnerabilities
    
    def _check_auth_vulnerabilities(self, content: str, file_path: str) -> List[Vulnerability]:
        """Check for authentication vulnerabilities."""
        vulnerabilities = []
        
        # Authentication patterns
        auth_patterns = [
            (r'password\s*=\s*["\'][^"\']{1,8}["\']', "Weak password detected"),
            (r'session\.permanent\s*=\s*True', "Permanent session without timeout"),
            (r'verify\s*=\s*False', "SSL verification disabled"),
            (r'check_hostname\s*=\s*False', "Hostname verification disabled")
        ]
        
        for pattern, description in auth_patterns:
            for match in re.finditer(pattern, content, re.IGNORECASE):
                line_num = content[:match.start()].count('\n') + 1
                vuln_id = hashlib.sha256(f"{file_path}:{line_num}:auth".encode()).hexdigest()[:16]
                
                vulnerabilities.append(Vulnerability(
                    vulnerability_id=vuln_id,
                    category=VulnerabilityCategory.BROKEN_AUTHENTICATION,
                    severity=VulnerabilitySeverity.HIGH,
                    confidence=0.7,
                    file_path=file_path,
                    line_number=line_num,
                    description=description,
                    recommendation="Implement strong authentication mechanisms",
                    cwe_id="CWE-287",
                    owasp_category="A07:2021"
                ))
        
        return vulnerabilities
    
    def _check_data_exposure(self, content: str, file_path: str) -> List[Vulnerability]:
        """Check for sensitive data exposure."""
        vulnerabilities = []
        
        # Sensitive data patterns
        sensitive_patterns = [
            (r'["\'](?:api[_-]?key|apikey)["\']?\s*[=:]\s*["\'][^"\']+["\']', "API key exposure"),
            (r'["\'](?:password|passwd|pwd)["\']?\s*[=:]\s*["\'][^"\']+["\']', "Password exposure"),
            (r'["\'](?:secret|token)["\']?\s*[=:]\s*["\'][^"\']+["\']', "Secret token exposure"),
            (r'print\s*\(\s*.*(?:password|secret|token|key)', "Sensitive data in logs")
        ]
        
        for pattern, description in sensitive_patterns:
            for match in re.finditer(pattern, content, re.IGNORECASE):
                line_num = content[:match.start()].count('\n') + 1
                vuln_id = hashlib.sha256(f"{file_path}:{line_num}:data_exposure".encode()).hexdigest()[:16]
                
                vulnerabilities.append(Vulnerability(
                    vulnerability_id=vuln_id,
                    category=VulnerabilityCategory.SENSITIVE_DATA_EXPOSURE,
                    severity=VulnerabilitySeverity.HIGH,
                    confidence=0.8,
                    file_path=file_path,
                    line_number=line_num,
                    description=description,
                    recommendation="Use environment variables or secure vaults for sensitive data",
                    cwe_id="CWE-798",
                    owasp_category="A02:2021"
                ))
        
        return vulnerabilities
    
    def _load_builtin_patterns(self) -> List[VulnerabilityPattern]:
        """Load built-in vulnerability patterns."""
        return []
    
    def _analyze_patterns(self, content: str, file_path: str) -> List[Vulnerability]:
        """Analyze content against patterns."""
        return []
    
    def _check_insecure_imports(self, node: Union[ast.Import, ast.ImportFrom], file_path: str) -> List[Vulnerability]:
        """Check for insecure imports."""
        return []
    
    def _check_hardcoded_secrets(self, node: ast.Str, file_path: str) -> List[Vulnerability]:
        """Check for hardcoded secrets in strings."""
        return []

class VulnerabilityDetectionFramework:
    """Comprehensive vulnerability detection framework."""
    
    def __init__(self, db_path: str = "vulnerability_detection.db"):
        self.db_path = db_path
        self.lock = RLock()
        self.static_analyzer = StaticAnalyzer()
        
        # Background thread for processing
        self.processing_thread = None
        self.stop_processing = False
        
        self._initialize_db()
        self._load_patterns()
    
    def _initialize_db(self):
        """Initialize database."""
        with sqlite3.connect(self.db_path) as conn:
            conn.executescript(VULNERABILITY_DETECTION_SCHEMA)
    
    def _load_patterns(self):
        """Load vulnerability patterns from database."""
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            cursor.execute('SELECT * FROM vulnerability_patterns')
            # Load patterns into memory for faster access
    
    def start_scan(self, target_path: str, scan_type: ScanType = ScanType.STATIC,
                   recursive: bool = True) -> str:
        """Start vulnerability scan."""
        session_id = hashlib.sha256(f"{target_path}:{time.time()}".encode()).hexdigest()[:16]
        
        # Create scan session
        session = ScanSession(
            session_id=session_id,
            scan_type=scan_type,
            target_path=target_path,
            metadata={"recursive": recursive}
        )
        
        self._save_scan_session(session)
        
        # Start background scanning
        scan_thread = threading.Thread(
            target=self._execute_scan,
            args=(session_id, target_path, scan_type, recursive)
        )
        scan_thread.daemon = True
        scan_thread.start()
        
        return session_id
    
    def _execute_scan(self, session_id: str, target_path: str, 
                     scan_type: ScanType, recursive: bool):
        """Execute vulnerability scan."""
        try:
            path = Path(target_path)
            files_to_scan = []
            
            if path.is_file():
                files_to_scan = [path]
            elif path.is_dir():
                pattern = "**/*" if recursive else "*"
                files_to_scan = [f for f in path.glob(pattern) 
                               if f.is_file() and f.suffix in ['.py', '.js', '.html', '.xml', '.json']]
            
            total_files = len(files_to_scan)
            self._update_scan_progress(session_id, total_files=total_files)
            
            all_vulnerabilities = []
            processed = 0
            
            for file_path in files_to_scan:
                try:
                    if scan_type in [ScanType.STATIC, ScanType.COMPREHENSIVE]:
                        vulnerabilities = self.static_analyzer.analyze_file(str(file_path))
                        all_vulnerabilities.extend(vulnerabilities)
                    
                    processed += 1
                    self._update_scan_progress(session_id, processed_files=processed,
                                             vulnerabilities_found=len(all_vulnerabilities))
                    
                except Exception as e:
                    logger.error(f"Error scanning {file_path}: {e}")
            
            # Save vulnerabilities
            for vuln in all_vulnerabilities:
                self._save_vulnerability(session_id, vuln)
            
            # Mark scan as completed
            self._complete_scan(session_id)
            
        except Exception as e:
            logger.error(f"Error in scan {session_id}: {e}")
            self._fail_scan(session_id, str(e))
    
    def get_scan_status(self, session_id: str) -> Optional[Dict[str, Any]]:
        """Get scan status."""
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            cursor.execute('''
                SELECT * FROM scan_sessions WHERE session_id = ?
            ''', (session_id,))
            row = cursor.fetchone()
            
            if row:
                return dict(row)
        return None
    
    def get_vulnerabilities(self, session_id: str = None, 
                           severity: VulnerabilitySeverity = None,
                           category: VulnerabilityCategory = None,
                           limit: int = 100) -> List[Vulnerability]:
        """Get vulnerabilities with filtering."""
        query = "SELECT * FROM vulnerabilities WHERE 1=1"
        params = []
        
        if session_id:
            query += " AND session_id = ?"
            params.append(session_id)
        
        if severity:
            query += " AND severity = ?"
            params.append(severity.value)
        
        if category:
            query += " AND category = ?"
            params.append(category.value)
        
        query += " ORDER BY discovered_at DESC LIMIT ?"
        params.append(limit)
        
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            cursor.execute(query, params)
            rows = cursor.fetchall()
            
            vulnerabilities = []
            for row in rows:
                vuln = Vulnerability(
                    id=row['id'],
                    vulnerability_id=row['vulnerability_id'],
                    category=VulnerabilityCategory(row['category']),
                    severity=VulnerabilitySeverity(row['severity']),
                    confidence=row['confidence'],
                    file_path=row['file_path'],
                    line_number=row['line_number'],
                    column_number=row['column_number'],
                    code_snippet=row['code_snippet'],
                    description=row['description'],
                    recommendation=row['recommendation'],
                    cwe_id=row['cwe_id'],
                    owasp_category=row['owasp_category'],
                    cvss_score=row['cvss_score'],
                    remediation_effort=row['remediation_effort'],
                    false_positive=bool(row['false_positive']),
                    verified=bool(row['verified']),
                    metadata=json.loads(row['metadata'] or '{}'),
                    discovered_at=datetime.fromisoformat(row['discovered_at'])
                )
                vulnerabilities.append(vuln)
            
            return vulnerabilities
    
    def _save_scan_session(self, session: ScanSession):
        """Save scan session to database."""
        with self.lock:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO scan_sessions 
                    (session_id, scan_type, target_path, status, metadata)
                    VALUES (?, ?, ?, ?, ?)
                ''', (
                    session.session_id,
                    session.scan_type.value,
                    session.target_path,
                    session.status,
                    json.dumps(session.metadata or {})
                ))
    
    def _save_vulnerability(self, session_id: str, vulnerability: Vulnerability):
        """Save vulnerability to database."""
        with self.lock:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT OR REPLACE INTO vulnerabilities 
                    (session_id, vulnerability_id, category, severity, confidence,
                     file_path, line_number, column_number, code_snippet,
                     description, recommendation, cwe_id, owasp_category,
                     cvss_score, remediation_effort, metadata)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    session_id,
                    vulnerability.vulnerability_id,
                    vulnerability.category.value,
                    vulnerability.severity.value,
                    vulnerability.confidence,
                    vulnerability.file_path,
                    vulnerability.line_number,
                    vulnerability.column_number,
                    vulnerability.code_snippet,
                    vulnerability.description,
                    vulnerability.recommendation,
                    vulnerability.cwe_id,
                    vulnerability.owasp_category,
                    vulnerability.cvss_score,
                    vulnerability.remediation_effort,
                    json.dumps(vulnerability.metadata or {})
                ))
    
    def _update_scan_progress(self, session_id: str, **kwargs):
        """Update scan progress."""
        with self.lock:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                
                updates = []
                params = []
                for key, value in kwargs.items():
                    updates.append(f"{key} = ?")
                    params.append(value)
                
                if updates:
                    query = f"UPDATE scan_sessions SET {', '.join(updates)} WHERE session_id = ?"
                    params.append(session_id)
                    cursor.execute(query, params)
    
    def _complete_scan(self, session_id: str):
        """Mark scan as completed."""
        with self.lock:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE scan_sessions 
                    SET status = 'completed', completed_at = CURRENT_TIMESTAMP 
                    WHERE session_id = ?
                ''', (session_id,))
    
    def _fail_scan(self, session_id: str, error_message: str):
        """Mark scan as failed."""
        with self.lock:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE scan_sessions 
                    SET status = 'failed', completed_at = CURRENT_TIMESTAMP,
                        metadata = json_set(COALESCE(metadata, '{}'), '$.error', ?)
                    WHERE session_id = ?
                ''', (error_message, session_id))
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get vulnerability statistics."""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            
            stats = {}
            
            # Total vulnerabilities
            cursor.execute('SELECT COUNT(*) FROM vulnerabilities')
            stats['total_vulnerabilities'] = cursor.fetchone()[0]
            
            # By severity
            cursor.execute('''
                SELECT severity, COUNT(*) FROM vulnerabilities 
                GROUP BY severity
            ''')
            stats['by_severity'] = dict(cursor.fetchall())
            
            # By category
            cursor.execute('''
                SELECT category, COUNT(*) FROM vulnerabilities 
                GROUP BY category
            ''')
            stats['by_category'] = dict(cursor.fetchall())
            
            # Recent scans
            cursor.execute('''
                SELECT COUNT(*) FROM scan_sessions 
                WHERE started_at > datetime('now', '-7 days')
            ''')
            stats['recent_scans'] = cursor.fetchone()[0]
            
            return stats

# Global instance
vulnerability_detection_framework = VulnerabilityDetectionFramework()

# Convenience functions
def start_vulnerability_scan(target_path: str, scan_type: ScanType = ScanType.STATIC) -> str:
    """Start vulnerability scan."""
    return vulnerability_detection_framework.start_scan(target_path, scan_type)

def get_scan_results(session_id: str) -> List[Vulnerability]:
    """Get scan results."""
    return vulnerability_detection_framework.get_vulnerabilities(session_id=session_id)

def get_vulnerability_statistics() -> Dict[str, Any]:
    """Get vulnerability statistics."""
    return vulnerability_detection_framework.get_statistics()