"""
Vulnerability Scanner

Scans code for security vulnerabilities and potential threats.
"""

import ast
import re
import json
from pathlib import Path
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


@dataclass
class Vulnerability:
    """Represents a security vulnerability."""
    type: str
    severity: str  # critical, high, medium, low
    file_path: str
    line_number: int
    description: str
    recommendation: str
    cwe_id: Optional[str]
    owasp_category: Optional[str]
    

class VulnerabilityScanner:
    """
    Comprehensive vulnerability scanner for Python code.
    Detects common security issues and provides remediation guidance.
    """
    
    def __init__(self):
        """Initialize the vulnerability scanner."""
        self.vulnerabilities = []
        self.scan_count = 0
        self.patterns = self._load_vulnerability_patterns()
        logger.info("Vulnerability Scanner initialized")
        
    def scan_file(self, file_path: str) -> List[Vulnerability]:
        """
        Scan a single file for vulnerabilities.
        
        Args:
            file_path: Path to file to scan
            
        Returns:
            List of discovered vulnerabilities
        """
        vulns = []
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                lines = content.splitlines()
                
            # AST-based analysis
            tree = ast.parse(content)
            vulns.extend(self._analyze_ast(tree, file_path))
            
            # Pattern-based analysis
            for i, line in enumerate(lines, 1):
                vulns.extend(self._check_patterns(line, i, file_path))
                
            # Specific vulnerability checks
            vulns.extend(self._check_sql_injection(content, file_path))
            vulns.extend(self._check_xss(content, file_path))
            vulns.extend(self._check_hardcoded_secrets(content, file_path))
            vulns.extend(self._check_insecure_random(tree, file_path))
            vulns.extend(self._check_unsafe_deserialization(tree, file_path))
            
            self.scan_count += 1
            self.vulnerabilities.extend(vulns)
            
        except Exception as e:
            logger.error(f"Error scanning {file_path}: {e}")
            
        return vulns
        
    def scan_directory(self, directory: str, recursive: bool = True) -> Dict[str, List[Vulnerability]]:
        """
        Scan directory for vulnerabilities.
        
        Args:
            directory: Directory to scan
            recursive: Scan subdirectories
            
        Returns:
            Dict mapping files to vulnerabilities
        """
        results = {}
        path = Path(directory)
        
        pattern = "**/*.py" if recursive else "*.py"
        for file_path in path.glob(pattern):
            if '__pycache__' not in str(file_path):
                vulns = self.scan_file(str(file_path))
                if vulns:
                    results[str(file_path)] = vulns
                    
        logger.info(f"Scanned {self.scan_count} files, found {len(self.vulnerabilities)} vulnerabilities")
        return results
        
    def generate_report(self) -> Dict[str, Any]:
        """
        Generate security report.
        
        Returns:
            Security report dictionary
        """
        report = {
            'scan_date': datetime.now().isoformat(),
            'files_scanned': self.scan_count,
            'total_vulnerabilities': len(self.vulnerabilities),
            'by_severity': self._count_by_severity(),
            'by_type': self._count_by_type(),
            'vulnerabilities': [self._vuln_to_dict(v) for v in self.vulnerabilities]
        }
        
        return report
        
    def export_report(self, output_path: str, format: str = "json") -> None:
        """
        Export security report to file.
        
        Args:
            output_path: Output file path
            format: Report format (json, html, markdown)
        """
        report = self.generate_report()
        
        if format == "json":
            with open(output_path, 'w') as f:
                json.dump(report, f, indent=2)
        elif format == "markdown":
            with open(output_path, 'w') as f:
                f.write(self._report_to_markdown(report))
        elif format == "html":
            with open(output_path, 'w') as f:
                f.write(self._report_to_html(report))
                
        logger.info(f"Exported report to {output_path}")
        
    # Specific vulnerability checks
    def _check_sql_injection(self, content: str, file_path: str) -> List[Vulnerability]:
        """Check for SQL injection vulnerabilities."""
        vulns = []
        sql_patterns = [
            r'execute\s*\(\s*["\'].*%[s|d].*["\'].*%',
            r'execute\s*\(\s*f["\'].*{.*}',
            r'cursor\.execute\s*\(\s*["\'].*\+',
        ]
        
        for pattern in sql_patterns:
            for match in re.finditer(pattern, content):
                line_num = content[:match.start()].count('\n') + 1
                vulns.append(Vulnerability(
                    type="SQL Injection",
                    severity="critical",
                    file_path=file_path,
                    line_number=line_num,
                    description="Potential SQL injection vulnerability",
                    recommendation="Use parameterized queries",
                    cwe_id="CWE-89",
                    owasp_category="A03:2021"
                ))
                
        return vulns
        
    def _check_xss(self, content: str, file_path: str) -> List[Vulnerability]:
        """Check for XSS vulnerabilities."""
        vulns = []
        xss_patterns = [
            r'render_template_string\s*\(',
            r'Markup\s*\(\s*.*user.*\)',
            r'\|safe(?!\w)',
        ]
        
        for pattern in xss_patterns:
            for match in re.finditer(pattern, content):
                line_num = content[:match.start()].count('\n') + 1
                vulns.append(Vulnerability(
                    type="Cross-Site Scripting",
                    severity="high",
                    file_path=file_path,
                    line_number=line_num,
                    description="Potential XSS vulnerability",
                    recommendation="Sanitize user input and use safe rendering",
                    cwe_id="CWE-79",
                    owasp_category="A03:2021"
                ))
                
        return vulns
        
    def _check_hardcoded_secrets(self, content: str, file_path: str) -> List[Vulnerability]:
        """Check for hardcoded secrets."""
        vulns = []
        secret_patterns = [
            (r'["\'](?:password|passwd|pwd)["\']?\s*[=:]\s*["\'][^"\']+["\']', "password"),
            (r'["\'](?:api[_-]?key|apikey)["\']?\s*[=:]\s*["\'][^"\']+["\']', "API key"),
            (r'["\'](?:secret|token)["\']?\s*[=:]\s*["\'][^"\']+["\']', "secret/token"),
        ]
        
        for pattern, secret_type in secret_patterns:
            for match in re.finditer(pattern, content, re.IGNORECASE):
                line_num = content[:match.start()].count('\n') + 1
                vulns.append(Vulnerability(
                    type="Hardcoded Secret",
                    severity="high",
                    file_path=file_path,
                    line_number=line_num,
                    description=f"Hardcoded {secret_type} detected",
                    recommendation="Use environment variables or secure vaults",
                    cwe_id="CWE-798",
                    owasp_category="A07:2021"
                ))
                
        return vulns
        
    def _check_insecure_random(self, tree: ast.AST, file_path: str) -> List[Vulnerability]:
        """Check for insecure random number generation."""
        vulns = []
        
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    if alias.name == 'random':
                        vulns.append(Vulnerability(
                            type="Insecure Random",
                            severity="medium",
                            file_path=file_path,
                            line_number=node.lineno,
                            description="Using insecure random for security-sensitive operations",
                            recommendation="Use secrets module for cryptographic randomness",
                            cwe_id="CWE-330",
                            owasp_category="A02:2021"
                        ))
                        
        return vulns
        
    def _check_unsafe_deserialization(self, tree: ast.AST, file_path: str) -> List[Vulnerability]:
        """Check for unsafe deserialization."""
        vulns = []
        
        for node in ast.walk(tree):
            if isinstance(node, ast.Call):
                if hasattr(node.func, 'attr'):
                    if node.func.attr in ['loads', 'load'] and hasattr(node.func.value, 'id'):
                        if node.func.value.id == 'pickle':
                            vulns.append(Vulnerability(
                                type="Unsafe Deserialization",
                                severity="critical",
                                file_path=file_path,
                                line_number=node.lineno,
                                description="Unsafe pickle deserialization",
                                recommendation="Use JSON or other safe formats",
                                cwe_id="CWE-502",
                                owasp_category="A08:2021"
                            ))
                            
        return vulns
        
    # Helper methods
    def _load_vulnerability_patterns(self) -> Dict[str, Any]:
        """Load vulnerability detection patterns."""
        return {
            'eval': {'pattern': r'\beval\s*\(', 'severity': 'critical'},
            'exec': {'pattern': r'\bexec\s*\(', 'severity': 'critical'},
            'os.system': {'pattern': r'os\.system\s*\(', 'severity': 'high'},
            'subprocess.shell': {'pattern': r'shell\s*=\s*True', 'severity': 'high'},
        }
        
    def _analyze_ast(self, tree: ast.AST, file_path: str) -> List[Vulnerability]:
        """Analyze AST for vulnerabilities."""
        vulns = []
        # AST analysis implementation
        return vulns
        
    def _check_patterns(self, line: str, line_num: int, file_path: str) -> List[Vulnerability]:
        """Check line against vulnerability patterns."""
        vulns = []
        
        for name, pattern_info in self.patterns.items():
            if re.search(pattern_info['pattern'], line):
                vulns.append(Vulnerability(
                    type=f"Dangerous Function: {name}",
                    severity=pattern_info['severity'],
                    file_path=file_path,
                    line_number=line_num,
                    description=f"Use of potentially dangerous function {name}",
                    recommendation="Review and validate usage",
                    cwe_id="CWE-676",
                    owasp_category="A03:2021"
                ))
                
        return vulns
        
    def _count_by_severity(self) -> Dict[str, int]:
        """Count vulnerabilities by severity."""
        counts = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}
        for vuln in self.vulnerabilities:
            counts[vuln.severity] += 1
        return counts
        
    def _count_by_type(self) -> Dict[str, int]:
        """Count vulnerabilities by type."""
        counts = {}
        for vuln in self.vulnerabilities:
            counts[vuln.type] = counts.get(vuln.type, 0) + 1
        return counts
        
    def _vuln_to_dict(self, vuln: Vulnerability) -> Dict[str, Any]:
        """Convert vulnerability to dictionary."""
        return {
            'type': vuln.type,
            'severity': vuln.severity,
            'file': vuln.file_path,
            'line': vuln.line_number,
            'description': vuln.description,
            'recommendation': vuln.recommendation,
            'cwe_id': vuln.cwe_id,
            'owasp': vuln.owasp_category
        }
        
    def _report_to_markdown(self, report: Dict) -> str:
        """Convert report to Markdown."""
        md = [f"# Security Scan Report", f"Date: {report['scan_date']}", ""]
        md.append(f"Files Scanned: {report['files_scanned']}")
        md.append(f"Total Vulnerabilities: {report['total_vulnerabilities']}")
        return "\n".join(md)
        
    def _report_to_html(self, report: Dict) -> str:
        """Convert report to HTML."""
        return f"<html><body><h1>Security Report</h1></body></html>"